rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive #
  ## D.cov[1:nsite, 1:nsite]  <- (sigma^2)*mexp(-delta*D[1:nsite, 1:nsite])#
#
  for(i in 1:nsite){#
    for(j in 1:nsite){#
      temp.cov[i, j] <- -delta*D[i, j]#
      D.cov[i, j]  <- (sigma^2)*exp(temp.cov[i, j])#
    }#
  }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)
Q
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250)
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250)
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))
Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))
plot(Xraster)
delta=1.5
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
  Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))
delta=1.5
plot(Xraster)
delta=0.1
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
  Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))
plot(Xraster)
sigma=2
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
  Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))
plot(Xraster)
sigma=0.1
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
  Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))
plot(Xraster)
sigma=2
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
  Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))
plot(Xraster)
elev <- raster(matrix(rnorm(n), ngrid, ngrid),#
                 xmn = 0, xmx = ngrid,#
                 ymn = 0, ymx = ngrid)#
  elev <- scale(elev)
psi <- expit(alpha + beta1 * raster::values(elev) +#
               raster::values(Xraster))
hist(psi)
Q
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive #
  ## D.cov[1:nsite, 1:nsite]  <- (sigma^2)*mexp(-delta*D[1:nsite, 1:nsite])#
#
  for(i in 1:nsite){#
    for(j in 1:nsite){#
      temp.cov[i, j] <- -delta*D[i, j]#
      D.cov[i, j]  <- (sigma^2)*exp(temp.cov[i, j])#
    }#
  }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
crossVal <- sum(sapply(crossValOut, function(x) x$crossValAverage),#
                  na.rm=TRUE)
crossVal
samples <- lapply(crossValOut, function(x) x$samples)
samples[[1]]
chain.diag <-  do.call(rbind,#
                         lapply(lapply(samples, geweke.diag),#
                                function(x) x$z))
chain.diag
lapply(samples, geweke.diag),#
                                function(x) x$z)
lapply(samples, geweke.diag)
samples
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
crossVal <- sum(sapply(crossValOut, function(x) x$crossValAverage),#
                  na.rm=TRUE)#
  samples <- lapply(crossValOut, function(x) x$samples)
samples
chain.diag <-  do.call(rbind,#
                         lapply(lapply(samples, geweke.diag),#
                                function(x) x$z))
?chain.diag
?gewke.diag
?geweke.diag
Q
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive #
  ## D.cov[1:nsite, 1:nsite]  <- (sigma^2)*mexp(-delta*D[1:nsite, 1:nsite])#
#
  for(i in 1:nsite){#
    for(j in 1:nsite){#
      temp.cov[i, j] <- -delta*D[i, j]#
      D.cov[i, j]  <- (sigma^2)*exp(temp.cov[i, j])#
    }#
  }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive #
  ## D.cov[1:nsite, 1:nsite]  <- (sigma^2)*mexp(-delta*D[1:nsite, 1:nsite])#
#
  for(i in 1:nsite){#
    for(j in 1:nsite){#
      temp.cov[i, j] <- -delta*D[i, j]#
      D.cov[i, j]  <- (sigma^2)*exp(temp.cov[i, j])#
    }#
  }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
library(nimble)#
library(coda)#
#
setwd('~/Dropbox/nimble/occupancy/analysis/multiSpp-singleSea')#
source('../all/plotting.R')#
save.dir <-  "../../../saved/multiSpp-singleSea/saved"#
#
## original model jags and nimble#
load(file=file.path(save.dir, "orig.Rdata"))#
#
## vectorized, likelihood for latent state, derived quantity#
## calculation#
load(file=file.path(save.dir, "opt1.Rdata"))#
#
## option 1 + custom block sampler on species random effect for each#
## species#
load(file=file.path(save.dir, "opt2.Rdata"))#
#
## ## option 1 + custom block sampler on species random effect for each#
## ## random effect type#
## load(file=file.path(save.dir, "opt3.Rdata")#
#
## option 1 + sigma sampler on random effects#
load(file=file.path(save.dir, "opt4.Rdata"))#
ms.ss.orig[[1]] <- rename_MCMC_comparison_method(c('nimble', 'jags'),#
                                                 c('NIMBLE-latent',#
                                                   'JAGS-latent'),#
                                                 comparison=ms.ss.orig[[1]])#
#
ms.ss.opt1[[1]] <- rename_MCMC_comparison_method(c('nimble',#
                                                   "autoBlock"),#
                                                 c('filter',#
                                                   'filter + autoblock'),#
                                                 comparison=ms.ss.opt1[[1]])#
ms.ss.opt2[[1]] <- rename_MCMC_comparison_method('nimbleOpt2',#
                                                 'filter + sp. block',#
                                                 comparison=ms.ss.opt2[[1]])#
## ms.ss.opt3[[1]] <- rename_MCMC_comparison_method('nimbleOpt3',#
##                                                  'block_2',#
##                                                  comparison=ms.ss.opt3[[1]])#
ms.ss.opt4[[1]] <- rename_MCMC_comparison_method('nimbleOpt4',#
                                                 'sigma sampler',#
                                                 comparison=ms.ss.opt4[[1]])#
#
## compare mcmcs#
ms.ss.occ.all <- combine_MCMC_comparison_results(ms.ss.orig[[1]],#
                                                 ms.ss.opt1[[1]],#
                                                 ms.ss.opt2[[1]],#
                                                 ## ms.ss.opt3[[1]],#
                                                 ## ms.ss.opt4[[1]],#
                                                 name = "ms.ss")#
#
make_MCMC_comparison_pages(ms.ss.occ.all,#
                           dir=file.path(save.dir, "../figures/comparisons"))#
## look at samples#
#
## checkChains(ms.ss.occ.all[[1]]$samples,#
##             f.path = file.path(save.dir,#
##             "../figures/chains/%s.pdf")#
## )#
## ****************************************#
## custom figs#
## ****************************************#
#
by.param <- apply(ms.ss.occ.all[[1]]$samples, c(1,2), effectiveSize)/#
  ms.ss.occ.all[[1]]$timing #
by.config <- ms.ss.occ.all[[1]]$efficiency#
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "MultiSpp-SingleSea",#
            at=0.4, adj1=0.03, adj2=0.1)
diffs <- eff.param-eff.param["JAGS-latent"]
diffs
eff.param["JAGS-latent"]
eff.param["JAGS-latent",]
eff.param
diffs <- eff.param-eff.param["JAGS-latent",]
diffs
eff.param["JAGS-latent",]
diffs <- apply(eff.param, 1, function(x) x - eff.param["JAGS-latent",])
diffs
diffs <- t(apply(eff.param, 1,#
                   function(x) x - eff.param["JAGS-latent",]))
diffs
diffs <- t(apply(eff.param, 1,#
                   function(x) x - eff.param["JAGS-latent",]))[-1,]
diffs
Q
library(RColorBrewer)#
#
pdf.f <- function(f, file, ...) {#
  cat(sprintf('Writing %s\n', file))#
  pdf(file, ...)#
  on.exit(dev.off())#
  f()#
}#
#
## function to plot values of parameters as a function of#
## iterations. Input is a MCMCcompare object#
#
checkChains <- function(all.mods.samps, f.path){#
  niter <- dim(all.mods.samps)[3]#
  params <- names(all.mods.samps[1,,1])#
  mods <- names(all.mods.samps[,1,1])#
  if(is.null(mods)) mods <- "nimble"#
#
  lapply(mods, function(z){#
    f <- function(){#
      layout(matrix(1:4, ncol=2))#
#
      apply(all.mods.samps[z,,], 1, function(x){#
        plot(x, type="l",#
             xlab = 'iteration',#
             main= params[which(apply(all.mods.samps[z,,], 1, function(y)#
               all(match(x,y))))]#
             )#
      })#
    }#
#
    pdf.f(f,#
          file= file.path(sprintf(f.path, z)),#
          height=11, width=8.5)#
  })#
}#
plotEffSize <- function(eff.size, eff.param,#
                        f.path, name, at, adj1, adj2,#
                        widths=c(4.5, 6)){#
  cols <- brewer.pal(length(eff.size$mean)+1, "Greys")[-1]#
  names(cols) <- names(eff.size$mean)#
  f <- function(){#
    layout(matrix(1:2, ncol=1))#
    par(oma=c(5, 7.5, 0.5, 1),#
        mar=c(0.5, 0, 3, 1), cex.axis=1.5)#
    ## barplots#
    mp1 <- barplot(eff.size$mean, names="", las=1, col=cols)#
    mtext("Mean", 3, line=0.5, cex=1.5)#
#
    mp2 <- barplot(eff.size$min, names="", las=1, col=cols)#
    text(mp2, par('usr')[3] - adj1,#
         srt = 45, adj = 1,#
         labels = names(eff.size$mean),#
         xpd = NA,#
         cex=1)#
#
    mtext("Minimum", 3, line=0.5, cex=1.5)#
    mtext("Effective sample size \n per second",#
          2, line=4.5, cex=1.5, at=at)#
  }#
#
  f2 <- function(){#
    layout(matrix(1:2, ncol=1), heights=c(1,3))#
#
    par(oma=c(5, 6, 0.5, 1),#
        mar=c(0.5, 0, 0.5, 1), cex.axis=1.5)#
#
    plot(NA, ylim=c(0,1), xlim=c(0,1), yaxt= "n", xaxt="n", bty="n")#
    legend("top", legend=rownames(eff.param),#
           pch=16, col=cols, bty="n", ncol=3)#
    plot(NA, ylim=log(range(eff.param)), xlim=c(1, ncol(eff.param)),#
         xlab="", ylab="", xaxt="n")#
    for(i in 1:nrow(eff.param)){#
      points(x=1:ncol(eff.param), y=log(eff.param[i,]),#
             col=cols[i],#
             pch=16,#
             xaxt="n",#
             type="o")#
    }#
    text(x=1:ncol(eff.param), par('usr')[3],#
         srt = 45, adj = 1 + adj2,#
         labels = colnames(eff.param),#
         xpd = NA,#
         cex=0.8)#
    mtext("Effective sample size \n per second (log)",#
          2, line=3.2, cex=1.5)#
  }#
#
    f3 <- function(){#
    layout(matrix(1:2, ncol=1), heights=c(1,3))#
#
    par(oma=c(5, 6, 0.5, 1),#
        mar=c(0.5, 0, 0.5, 1), cex.axis=1.5)#
    diffs <- t(apply(eff.param, 1,#
                   function(x) x - eff.param["JAGS-latent",]))[-1,]#
    plot(NA, ylim=c(0,1), xlim=c(0,1), yaxt= "n", xaxt="n", bty="n")#
    legend("top", legend=rownames(diffs),#
           pch=16, col=cols[-1], bty="n", ncol=3)#
    plot(NA, ylim=log(range(diffs)), xlim=c(1, ncol(diffs)),#
         xlab="", ylab="", xaxt="n")#
    for(i in 1:nrow(diffs)){#
      points(x=1:ncol(diffs), y=log(diffs[i,]),#
             col=cols[i+1],#
             pch=16,#
             xaxt="n",#
             type="o")#
    }#
    text(x=1:ncol(diffs), par('usr')[3],#
         srt = 45, adj = 1 + adj2,#
         labels = colnames(diffs),#
         xpd = NA,#
         cex=0.8)#
    mtext("Difference in effective sample size \n per second (log)",#
          2, line=3.2, cex=1.5)#
  }#
  pdf.f(f,#
        file= file.path(sprintf(f.path, name, "Bar")),#
        height=6, width=widths[1])#
  pdf.f(f2,#
        file= file.path(sprintf(f.path, name, "Points")),#
        height=4, width=widths[2])#
  pdf.f(f3,#
        file= file.path(sprintf(f.path, name, "Diffs")),#
        height=4, width=widths[2])#
}
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "MultiSpp-SingleSea",#
            at=0.4, adj1=0.03, adj2=0.1)
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "MultiSpp-SingleSea",#
            at=0.4, adj1=0.03, adj2=0.1)
rm(list=ls())#
library(nimble)#
setwd("~/Dropbox/nimble/occupancy/analysis/singleSpp-multiSea")#
source('../all/plotting.R')#
save.dir <- "../../../saved/singleSpp-multiSea/saved"#
#
## original model jags and nimble#
load(file=file.path(save.dir, "orig.Rdata"))#
#
## custom sampler for zs, slice for other parms#
load(file=file.path(save.dir, "opt2.Rdata"))#
#
## custom function for latent state#
load(file=file.path(save.dir, "opt4.Rdata"))#
#
## costum function for latent state + block samplers on phi[i-1],#
## gamma[i-1]#
load(file=file.path(save.dir, "opt5.Rdata")) #
#
## rename results#
#
ss.ms.orig[[1]] <- rename_MCMC_comparison_method(c('nimble', 'jags'),#
                                                 c('NIMBLE-latent',#
                                                   'JAGS-latent'),#
                                                 comparison=ss.ms.orig[[1]])#
ss.ms.opt2[[1]] <- rename_MCMC_comparison_method('nimbleOpt2',#
                                                 'slice',#
                                                 comparison=ss.ms.opt2[[1]])#
#
ss.ms.opt4[[1]] <- rename_MCMC_comparison_method(c('nimble',#
                                                   'autoBlock',#
                                                   'nimble_slice'),#
                                                 c('filter',#
                                                   'filter + autoblock',#
                                                   'filter + slice'),#
                                                 comparison=ss.ms.opt4[[1]])#
#
## ss.ms.opt5[[1]] <- rename_MCMC_comparison_method('nimbleOpt5',#
##                                                  'block phi gam',#
##                                                  comparison=ss.ms.opt5[[1]])#
## compare mcmcs#
ss.ms.occ.all <- combine_MCMC_comparison_results(ss.ms.orig[[1]],#
                                                 ## ss.ms.opt2[[1]],#
                                                 ss.ms.opt4[[1]],#
                                                 ## ss.ms.opt5[[1]],#
                                                 name = "ss.ms" )#
#
make_MCMC_comparison_pages(ss.ms.occ.all,#
                           dir=file.path(save.dir, "../figures/comparisons"))#
## checkChains(ss.ms.occ.all[[1]]$samples,#
##             f.path = file.path(save.dir,#
##               "../figures/chains/%s.pdf")#
##             )#
## ****************************************#
## custom figs#
## ****************************************#
#
by.param <- apply(ss.ms.occ.all[[1]]$samples, c(1,2), effectiveSize)/#
  ss.ms.occ.all[[1]]$timing#
by.config <- ss.ms.occ.all[[1]]$efficiency#
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "SingleSpp-MultiSea",#
            at=9, adj1=0.3, adj2=0.3, widths=c(4.5, 8.5))
?abline
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "SingleSpp-MultiSea",#
            at=9, adj1=0.3, adj2=0.3, widths=c(4.5, 8.5))
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "SingleSpp-MultiSea",#
            at=9, adj1=0.3, adj2=0.3, widths=c(4.5, 8.5))
?abline
?abline
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "SingleSpp-MultiSea",#
            at=9, adj1=0.3, adj2=0.3, widths=c(4.5, 8.5))
rm(list=ls())#
library(nimble)#
library(coda)#
#
setwd('~/Dropbox/nimble/occupancy/analysis/multiSpp-singleSea')#
source('../all/plotting.R')#
save.dir <-  "../../../saved/multiSpp-singleSea/saved"#
#
## original model jags and nimble#
load(file=file.path(save.dir, "orig.Rdata"))#
#
## vectorized, likelihood for latent state, derived quantity#
## calculation#
load(file=file.path(save.dir, "opt1.Rdata"))#
#
## option 1 + custom block sampler on species random effect for each#
## species#
load(file=file.path(save.dir, "opt2.Rdata"))#
#
## ## option 1 + custom block sampler on species random effect for each#
## ## random effect type#
## load(file=file.path(save.dir, "opt3.Rdata")#
#
## option 1 + sigma sampler on random effects#
load(file=file.path(save.dir, "opt4.Rdata"))#
ms.ss.orig[[1]] <- rename_MCMC_comparison_method(c('nimble', 'jags'),#
                                                 c('NIMBLE-latent',#
                                                   'JAGS-latent'),#
                                                 comparison=ms.ss.orig[[1]])#
#
ms.ss.opt1[[1]] <- rename_MCMC_comparison_method(c('nimble',#
                                                   "autoBlock"),#
                                                 c('filter',#
                                                   'filter + autoblock'),#
                                                 comparison=ms.ss.opt1[[1]])#
ms.ss.opt2[[1]] <- rename_MCMC_comparison_method('nimbleOpt2',#
                                                 'filter + sp. block',#
                                                 comparison=ms.ss.opt2[[1]])#
## ms.ss.opt3[[1]] <- rename_MCMC_comparison_method('nimbleOpt3',#
##                                                  'block_2',#
##                                                  comparison=ms.ss.opt3[[1]])#
ms.ss.opt4[[1]] <- rename_MCMC_comparison_method('nimbleOpt4',#
                                                 'sigma sampler',#
                                                 comparison=ms.ss.opt4[[1]])#
#
## compare mcmcs#
ms.ss.occ.all <- combine_MCMC_comparison_results(ms.ss.orig[[1]],#
                                                 ms.ss.opt1[[1]],#
                                                 ms.ss.opt2[[1]],#
                                                 ## ms.ss.opt3[[1]],#
                                                 ## ms.ss.opt4[[1]],#
                                                 name = "ms.ss")#
#
make_MCMC_comparison_pages(ms.ss.occ.all,#
                           dir=file.path(save.dir, "../figures/comparisons"))#
## look at samples#
#
## checkChains(ms.ss.occ.all[[1]]$samples,#
##             f.path = file.path(save.dir,#
##             "../figures/chains/%s.pdf")#
## )#
## ****************************************#
## custom figs#
## ****************************************#
#
by.param <- apply(ms.ss.occ.all[[1]]$samples, c(1,2), effectiveSize)/#
  ms.ss.occ.all[[1]]$timing #
by.config <- ms.ss.occ.all[[1]]$efficiency#
#
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "MultiSpp-SingleSea",#
            at=0.4, adj1=0.03, adj2=0.1)
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "MultiSpp-SingleSea",#
            at=0.4, adj1=0.03, adj2=0.1)
rm(list=ls())#
library(nimble)#
setwd("~/Dropbox/nimble/occupancy/analysis/singleSpp-multiSea")#
source('../all/plotting.R')#
save.dir <- "../../../saved/singleSpp-multiSea/saved"#
#
## original model jags and nimble#
load(file=file.path(save.dir, "orig.Rdata"))#
#
## custom sampler for zs, slice for other parms#
load(file=file.path(save.dir, "opt2.Rdata"))#
#
## custom function for latent state#
load(file=file.path(save.dir, "opt4.Rdata"))#
#
## costum function for latent state + block samplers on phi[i-1],#
## gamma[i-1]#
load(file=file.path(save.dir, "opt5.Rdata")) #
#
## rename results#
#
ss.ms.orig[[1]] <- rename_MCMC_comparison_method(c('nimble', 'jags'),#
                                                 c('NIMBLE-latent',#
                                                   'JAGS-latent'),#
                                                 comparison=ss.ms.orig[[1]])#
ss.ms.opt2[[1]] <- rename_MCMC_comparison_method('nimbleOpt2',#
                                                 'slice',#
                                                 comparison=ss.ms.opt2[[1]])#
#
ss.ms.opt4[[1]] <- rename_MCMC_comparison_method(c('nimble',#
                                                   'autoBlock',#
                                                   'nimble_slice'),#
                                                 c('filter',#
                                                   'filter + autoblock',#
                                                   'filter + slice'),#
                                                 comparison=ss.ms.opt4[[1]])#
#
## ss.ms.opt5[[1]] <- rename_MCMC_comparison_method('nimbleOpt5',#
##                                                  'block phi gam',#
##                                                  comparison=ss.ms.opt5[[1]])#
## compare mcmcs#
ss.ms.occ.all <- combine_MCMC_comparison_results(ss.ms.orig[[1]],#
                                                 ## ss.ms.opt2[[1]],#
                                                 ss.ms.opt4[[1]],#
                                                 ## ss.ms.opt5[[1]],#
                                                 name = "ss.ms" )#
#
make_MCMC_comparison_pages(ss.ms.occ.all,#
                           dir=file.path(save.dir, "../figures/comparisons"))#
## checkChains(ss.ms.occ.all[[1]]$samples,#
##             f.path = file.path(save.dir,#
##               "../figures/chains/%s.pdf")#
##             )#
## ****************************************#
## custom figs#
## ****************************************#
#
by.param <- apply(ss.ms.occ.all[[1]]$samples, c(1,2), effectiveSize)/#
  ss.ms.occ.all[[1]]$timing#
by.config <- ss.ms.occ.all[[1]]$efficiency#
source('../all/plotting.R')#
plotEffSize(by.config, by.param, f.path= file.path(save.dir,#
              "../figures/comparisons/%s%s.pdf"), "SingleSpp-MultiSea",#
            at=9, adj1=0.3, adj2=0.3, widths=c(4.5, 8.5))
