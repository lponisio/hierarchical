neededObjects <<- nimbleInternalFunctions$buildNeededObjects(Robject,
compiledNodeFun, neededObjects, dll, nimbleProject)
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
nimbleProject
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
neededObjects <<- nimbleInternalFunctions$buildNeededObjects(Robject, compiledNodeFun, neededObjects, dll, nimbleProject)
nimbleProject
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
Robject
compiledNodeFun
neededObjects
dll
nimbleProject
newRobject
Robject
Robj
compiledNodeFun
neededObject
neededObjects
dll
nimbleProject
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
Robject
neededObjects
dll
nimbleProject
Robj
nimble:::nimbleInternalFunctions
nimble:::nimbleInternalFunctions$buildNeededObjects()
nimble:::nimbleInternalFunctions$buildNeededObjects
nimble:::nimbleInternalFunctions$buildNeededObjects
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
compiledNodeFun$nfProc$neededObjectNames
iName <- "initFunctionList"
thisObj <- Robj[[iName]]
Robj[[iName]]
neededObjects
neededObjects[[iName]] <- nimPointerList(thisObj$baseClass, length(thisObj$contentsList))
neededObjects[[iName]]
seq_along(thisObj$contentsList)
i = 1
RCO <- nf_getRefClassObject(thisObj[[i]])
RCO
nimbleProject
project
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
set.seed(1)
exampleCode <- nimbleCode({
x[1] ~ dnorm(0, var = 1)
y[1] ~ dnorm(x[1], var = .5)
for(t in 2:10){
x[t] ~ dnorm(.8 * x[t-1], var = 1)
y[t] ~ dnorm(x[t], var = .5)
}
})
exampleModel <- nimbleModel(code = exampleCode,
inits = list(x = rep(0, 10)),
data = list(y = rep(0, 10)))
simulate(exampleModel, 'x')
calculate(exampleModel, exampleModel$getDependencies('x'))
simulate(exampleModel, 'y', includeData = T)
exampleBootstrapFilter <- buildBootstrapFilter(exampleModel, nodes = 'x',
control = list(saveAll = TRUE, thresh = .9))
CexampleModel <- compileNimble(exampleModel)
CexampleBootstrapFilter <- compileNimble(exampleBootstrapFilter,
project = exampleModel)
CexampleBootstrapFilter$run(10)
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
## This is an initial klugey way to define the types.  I am using it only because we already
## have a function that turns this information into a symbolTable, which is the key
## I figure later we can easily create symbol tables more flexibly.
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
## example of making a symbol table:
nimble:::buildSymbolTable(testTypes$vars, testTypes$types, testTypes$sizes)
## make a nimbleList (implementation to be changed later)
myListDef <- nimble:::nimbleList(types = testTypes)
myListDef <- nimbleList(types = testTypes)
myList <- myListDef(a = 10)
## this is set up as an R list simply with a couple of attributes
## but I now realize we should make it a reference class for a few reasons
myList$a
## put this information into an nlProcessing object (like nfProcessing, but will be much simpler)
nlp <- nimble:::nlProcessing()
nlp$nimbleListDef <- myList$nlDefClass
nlp$buildSymbolTable()
nlp$process()
cppDef <- nimble:::cppNimbleListClass(name = 'testList', nimCompProc = nlp)
cppDef$buildAll(where = globalenv())
nimble:::writeCode(cppDef$generate())
nimble:::writeCode(cppDef$generate(declaration = FALSE))
## bare bones result with c++ output to build upon
myListDef
myList <- myListDef(a = 10)
myList$a
nlp$nimbleListDef <- myList$nlDefClassObj
nlp$buildSymbolTable()
nlp$process()
cppDef <- nimble:::cppNimbleListClass(name = 'testList', nimCompProc = nlp)
cppDef$buildAll(where = globalenv())
?deparse
?substitute
?setRefClass
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
## This is an initial klugey way to define the types.  I am using it only because we already
## have a function that turns this information into a symbolTable, which is the key
## I figure later we can easily create symbol tables more flexibly.
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
## example of making a symbol table:
nimble:::buildSymbolTable(testTypes$vars, testTypes$types, testTypes$sizes)
## make a nimbleList (implementation to be changed later)
myListDef <- nimble:::nimbleList(types = testTypes)
myListDef <- nimbleList(types = testTypes)
myList <- myListDef(a = 10)
## this is set up as an R list simply with a couple of attributes
## but I now realize we should make it a reference class for a few reasons
myList$a
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
## This is an initial klugey way to define the types.  I am using it only because we already
## have a function that turns this information into a symbolTable, which is the key
## I figure later we can easily create symbol tables more flexibly.
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
## example of making a symbol table:
nimble:::buildSymbolTable(testTypes$vars, testTypes$types, testTypes$sizes)
## make a nimbleList (implementation to be changed later)
myListDef <- nimble:::nimbleList(types = testTypes)
myListDef <- nimbleList(types = testTypes)
myList <- myListDef(a = 10)
## this is set up as an R list simply with a couple of attributes
## but I now realize we should make it a reference class for a few reasons
myList$a
compileNimble(myList)
dotsDeparses
origList
?attr
nimble:::nf_getRefClassObject
myList
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
## This is an initial klugey way to define the types.  I am using it only because we already
## have a function that turns this information into a symbolTable, which is the key
## I figure later we can easily create symbol tables more flexibly.
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
## example of making a symbol table:
nimble:::buildSymbolTable(testTypes$vars, testTypes$types, testTypes$sizes)
## make a nimbleList (implementation to be changed later)
myListDef <- nimble:::nimbleList(types = testTypes)
myListDef <- nimbleList(types = testTypes)
myList <- myListDef(a = 10)
nimbleList
myListDef <- nimble:::nimbleList(types = testTypes)
myListDef
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
myListDef <- nimble:::nimbleList(types = testTypes)
myListDef
myList <- myListDef(a = 10)
myList
myList <- myListDef(a = 10, b = 12)
myList
myList <- myListDef(a = 10)
myList
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
## This is an initial klugey way to define the types.  I am using it only because we already
## have a function that turns this information into a symbolTable, which is the key
## I figure later we can easily create symbol tables more flexibly.
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
## example of making a symbol table:
nimble:::buildSymbolTable(testTypes$vars, testTypes$types, testTypes$sizes)
## make a nimbleList (implementation to be changed later)
myListDef <- nimble:::nimbleList(types = testTypes)
fields
name
nimble:::nimbleList
myListDef
myListDef$initialize
myListDef$new
myList <- myListDef(a = 10)
myList
myList$b
myList$b <- 10
myList$b
myList
myList$name
myList[['name']]
nimble:::nf_getRefClassObject
nimble:::nfGetDefVar
?environment
nimble:::nf_getGeneratorFunction
?assign
eixsts('name', envir = myList)
exists('name', envir = myList)
exists('a', envir = myList)
exists('where', envir = myList)
exists('b', envir = myList)
?exists
tst <- list(a = 1)
inherits(tst, 'list')
?inherits
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
## This is an initial klugey way to define the types.  I am using it only because we already
## have a function that turns this information into a symbolTable, which is the key
## I figure later we can easily create symbol tables more flexibly.
testTypes <- list(vars = c('a','b'), types = c('double','double'), sizes = list('NA','NA'))
## example of making a symbol table:
nimble:::buildSymbolTable(testTypes$vars, testTypes$types, testTypes$sizes)
## make a nimbleList (implementation to be changed later)
myListDef <- nimble:::nimbleList(types = testTypes)
myList <- myListDef(a = 10)
compileNimble(myList)
source('~/GitHub/occupancy-nimble/analysis/cppp/src/calcCPPP.R')
setwd("C:/Users/iateb/Dropbox/nimble/occupancy/analysis/singleSpp-multiSea")
source('src/initialize.R')
data <- genDynamicOccData()
model.input <- prepModDataOcc(data)
## *********************************************************************
##  Multi-season occupancy model: custom z sampler
## *********************************************************************
ss.ms.occ <- nimbleCode({
## Specify priors
psi1 ~ dunif(0, 1)
for(k in 1:(nyear-1)){
phi[k] ~ dunif(0, 1)
gamma[k] ~ dunif(0, 1)
p[k] ~ dunif(0, 1)
}
p[nyear] ~ dunif(0, 1)
## Ecological submodel: Define state conditional on parameters
for (i in 1:nsite){
z[i,1] ~ dbern(psi1)
for (k in 2:nyear){
muZ[i,k]<- z[i,k-1]*phi[k-1] + (1-z[i,k-1])*gamma[k-1]
z[i,k] ~ dbern(muZ[i,k])
}
}
## Observation model
for (i in 1:nsite){
for (j in 1:nrep){
for (k in 1:nyear){
muy[i,j,k] <- z[i,k]*p[k]
y[i,j,k] ~ dbern(muy[i,j,k])
}
}
}
})
input1 <- c(code=ss.ms.occ,
model.input)
## *********************************************************************
## opt 2: add custom z sampler and slice on uniform(0,1) nodes
## *********************************************************************
MCMCdefs.opt2 <- list('nimbleOpt2' = quote({
customSpec <- configureMCMC(Rmodel)
customSpec$removeSamplers('phi', print=FALSE)
customSpec$removeSamplers('gamma', print=FALSE)
customSpec$removeSamplers('p', print=FALSE)
customSpec$removeSamplers('psi1', print=FALSE)
## happens to be all top nodes
zeroOneNodes <- Rmodel$getNodeNames(topOnly = TRUE)
for(zon in zeroOneNodes) customSpec$addSampler(target = zon,
type =
"slice",
print=FALSE)
customSpec
}))
## *********************************************************************
## run with compareMCMCs
## ss.ms.opt2 <- compareMCMCs(input1,
##                            MCMCs=c('nimbleOpt2'),
##                            MCMCdefs = MCMCdefs.opt2,
##                            niter= niter,
##                            burnin = burnin,
##                            summary=FALSE,
##                            check=FALSE)
## save(ss.ms.opt2, file=file.path(save.dir, "opt2.Rdata"))
## *********************************************************************
## model assessment
## *********************************************************************
## build model
occ.R.model <- nimbleModel(code=ss.ms.occ,
constants=input1$constants,
data=input1$data,
inits=input1$inits,
check=FALSE)
## ad auto blocking
## customSpec <- configureMCMC(occ.R.model, autoBlock=TRUE)
occ.mcmc <- buildMCMC(occ.R.model)
occ.C.model <- compileNimble(occ.R.model)
occ.C.mcmc <- compileNimble(occ.mcmc, project = occ.R.model)
occ.C.mcmc$run(1000)
source('../cppp/src/calcCPPP.R', chdir = TRUE)
options(mc.cores=1)
test.opt2 <- generateCPPP(occ.R.model,
occ.C.model,
occ.C.mcmc,
occ.mcmc,
dataName = 'y',
paramNames = input1$monitors,
MCMCIter = 1000,
NSamp = 100,
NPDist = 50,
burnInProportion = 0.10,
thin = 1,
averageParams = TRUE,
discFuncGenerator=likeDiscFuncGenerator)
test.opt2
F==0
source('~/GitHub/occupancy-nimble/analysis/cppp/src/calcCPPP.R')
library(coda)
plot(as.mcmc(occ.C.mcmc$mvSamples))
as.mcmc(occ.C.mcmc$mvSamples)
occ.C.mcmc$mvSamples
as.matrix(occ.C.mcmc$mvSamples)
plot(as.mcmc(as.matrix(occ.C.mcmc$mvSamples)))
