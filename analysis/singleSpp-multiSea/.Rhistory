returnType(testListDef())
return(argList)
}
)
# testTypes <- list(vars = c('a','b'), types = c('double(0)','double(0)'))
# simpListDef <- nimble:::nimbleList(testTypes)
testInst <- testFunc()
setupOutputNames
setupOutputNames
nf_getNestedListNames(setup,
unique(setupOutputNames)
)
nf_getNestedListNames()
nf_getNestedListNames
trace(nimble:::nf_getNestedListNames, browser)
testFunc <- nimbleFunction(
setup = function(){
testTypes1 <- list(vars = c('a','b'), types = c('double(0)','double(0)'))
simpListDef <- nimble:::nimbleList(testTypes1)
testTypes2 <- list(vars = c('a','b'), types = c('double(1)','simpListDef()'))
testListDef <- nimble:::nimbleList(testTypes2)
oneToThree <- c(1.5,3.4,3.2)
},
run = function(){
# tmp <- 1 + 2
argList <- testListDef$new()
# setSize(argList$a, tmp)
# argList$a <- argList$a*2
returnType(testListDef())
return(argList)
}
)
# testTypes <- list(vars = c('a','b'), types = c('double(0)','double(0)'))
# simpListDef <- nimble:::nimbleList(testTypes)
testInst <- testFunc()
testFunc <- nimbleFunction(
setup = function(){
testTypes1 <- list(vars = c('a','b'), types = c('double(0)','double(0)'))
simpListDef <- nimble:::nimbleList(testTypes1)
testTypes2 <- list(vars = c('a','b'), types = c('double(1)','simpListDef()'))
testListDef <- nimble:::nimbleList(testTypes2)
oneToThree <- c(1.5,3.4,3.2)
},
run = function(){
# tmp <- 1 + 2
argList <- testListDef$new()
# setSize(argList$a, tmp)
# argList$a <- argList$a*2
returnType(testListDef())
return(argList)
}
)
setup
possibleNLNames
nlExtractFunction[[4]]
nlExtractFunction[[4]]
returnNestedListNames <- eval(nlExtractFunction[[3]])
returnSetupNames
.var_unique_name_1415927
nf_nestedNimbleListExtraction(get(.var_unique_name_1415927),
setupLHSVars)
browser(nf_nestedNimbleListExtraction)
setupLHSVars
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(nimble)
nimbleOptions(showCompilerOutput = TRUE)
nimbleOptions(debugCppLineByLine = FALSE)
# nimbleOptions(debugSizeProcessing = TRUE)
# debug(nimble:::sizeAssignAfterRecursing)
options( warn = 1 )
testFunc <- nimbleFunction(
setup = function(){
testTypes1 <- list(vars = c('a','b'), types = c('double(0)','double(0)'))
simpListDef <- nimble:::nimbleList(testTypes1)
testTypes2 <- list(vars = c('a','b'), types = c('double(1)','simpListDef()'))
testListDef <- nimble:::nimbleList(testTypes2)
oneToThree <- c(1.5,3.4,3.2)
},
run = function(){
# tmp <- 1 + 2
argList <- testListDef$new()
# setSize(argList$a, tmp)
# argList$a <- argList$a*2
returnType(testListDef())
return(argList)
}
)
eval(nlExtractFunction[[4]])
eval(nlExtractFunction[[3]])
returnSetupNames
setupLHSVars
nf_assignmentLHSvars
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-1.tar.gz", repos = NULL, type="source")
library(devtools)
setwd("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages")
devtools:::build("nimble")
install.packages("C:\\Users\\iateb\\Documents\\GitHub\\nimble\\packages\\nimble_0.6-2.tar.gz", repos = NULL, type="source")
library(nimble)
ss.ms.occ <- nimbleCode({
## Specify priors
psi1 ~ dunif(0, 1)
for(k in 1:(nyear-1)){
phi[k] ~ dunif(0, 1)
gamma[k] ~ dunif(0, 1)
p[k] ~ dunif(0, 1)
}
p[nyear] ~ dunif(0, 1)
## Ecological submodel: Define state conditional on parameters
for (i in 1:nsite){
z[i,1] ~ dbern(psi1)
for (k in 2:nyear){
muZ[i,k]<- z[i,k-1]*phi[k-1] + (1-z[i,k-1])*gamma[k-1]
z[i,k] ~ dbern(muZ[i,k])
}
}
## Observation model
for (i in 1:nsite){
for (j in 1:nrep){
for (k in 1:nyear){
muy[i,j,k] <- z[i,k]*p[k]
y[i,j,k] ~ dbern(muy[i,j,k])
}
}
}
})
input1 <- c(code=ss.ms.occ,
model.input)
setwd("~/GitHub/occupancy-nimble/analysis/singleSpp-multiSea")
source('src/initialize.R')
set.seed(444)
data <- genDynamicOccData()
model.input <- prepModDataOcc(data)
ss.ms.occ <- nimbleCode({
## Specify priors
psi1 ~ dunif(0, 1)
for(k in 1:(nyear-1)){
phi[k] ~ dunif(0, 1)
gamma[k] ~ dunif(0, 1)
p[k] ~ dunif(0, 1)
}
p[nyear] ~ dunif(0, 1)
## Ecological submodel: Define state conditional on parameters
for (i in 1:nsite){
z[i,1] ~ dbern(psi1)
for (k in 2:nyear){
muZ[i,k]<- z[i,k-1]*phi[k-1] + (1-z[i,k-1])*gamma[k-1]
z[i,k] ~ dbern(muZ[i,k])
}
}
## Observation model
for (i in 1:nsite){
for (j in 1:nrep){
for (k in 1:nyear){
muy[i,j,k] <- z[i,k]*p[k]
y[i,j,k] ~ dbern(muy[i,j,k])
}
}
}
})
input1 <- c(code=ss.ms.occ,
model.input)
occ.R.model <- nimbleModel(code=ss.ms.occ,
constants=input1$constants,
data=input1$data,
inits=input1$inits,
check=FALSE)
occ.R.model[['z']]
nimDim(occ.R.model[['z']])
nimDim(occ.R.model[['z']])[1]
nimble:::numeric
nimble:::nimNumeric
sample
sample.int
?sample
model$z
occ.R.model$z
occ.R.model$z[1,1] <- NA
occ.R.model$z
calculate(model$mu)
calculate(occ.R.model$mu)
calculate(occ.R.model$muZ)
z
z
occ.R.model$muZ
occ.R.model <- nimbleModel(code=ss.ms.occ,
constants=input1$constants,
data=input1$data,
inits=input1$inits,
check=FALSE)
calculate(occ.R.model$muZ)
calculate(occ.R.model$muy)
occ.R.model <- nimbleModel(code=ss.ms.occ,
constants=input1$constants,
data=input1$data,
inits=input1$inits,
check=FALSE)
occ.R.model$muy
simulate(occ.R.model)
occ.R.model$muy
occ.R.model$z[1,1] <- NA
calculate(occ.R.model$muZ)
occ.R.model$muZ
occ.R.model$z
calculate(psi1)
calculate(occ.R.model$psi1)
?calculate
nimCalculate(occ.R.model$psi1)
calculate(occ.R.model$psi1)
setwd("~/GitHub/occupancy-nimble/analysis/singleSpp-multiSea")
source('src/initialize.R')
set.seed(444)
data <- genDynamicOccData()
model.input <- prepModDataOcc(data)
ss.ms.occ <- nimbleCode({
## Specify priors
psi1 ~ dunif(0, 1)
for(k in 1:(nyear-1)){
phi[k] ~ dunif(0, 1)
gamma[k] ~ dunif(0, 1)
p[k] ~ dunif(0, 1)
}
p[nyear] ~ dunif(0, 1)
## Ecological submodel: Define state conditional on parameters
for (i in 1:nsite){
z[i,1] ~ dbern(psi1)
for (k in 2:nyear){
muZ[i,k]<- z[i,k-1]*phi[k-1] + (1-z[i,k-1])*gamma[k-1]
z[i,k] ~ dbern(muZ[i,k])
}
}
## Observation model
for (i in 1:nsite){
for (j in 1:nrep){
for (k in 1:nyear){
muy[i,j,k] <- z[i,k]*p[k]
y[i,j,k] ~ dbern(muy[i,j,k])
}
}
}
})
input1 <- c(code=ss.ms.occ,
model.input)
occ.R.model <- nimbleModel(code=ss.ms.occ,
constants=input1$constants,
data=input1$data,
inits=input1$inits,
check=FALSE)
occ.R.model$z[1,1] <- NA
calculate(occ.R.model$psi1)
?calculate
occ.R.model$z[1,1] <- 1
calculate(occ.R.model$psi1)
print("hi")
number <- calculate(occ.R.model$psi1)
number
simulate(occ.R.model)
number <- calculate(occ.R.model$psi1)
number
occ.R.model$psi1
occ.R.model$getDependencies("psi1")
occ.R.model$z
calculate(occ.R.model)
number <- calculate(occ.R.model$psi1)
number
calculate(occ.R.model$z)
number <- calculate(occ.R.model$z)
number
occ.R.model$getDependencies('z')
occ.R.model$y
RW_sampler_latentSubsamp <- nimbleFunction(
contains = sampler_BASE,
setup = function(model, mvSaved, target, control, leaveOutIndices) {
regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
latentNodes <- control$latentNodes
leaveOutIndex <- control$leaveOutIndex
leaveOutProportion <- control$leaveOutProportion
latentNodeLength <- nimDim(model[[latentNodes]])[leaveOutIndex]
leaveOutNumber <- floor(leaveOutProportion*latentNodeLength)
numberOfLeaveOutOptions <- dim(leaveOutIndices)[2]
},
run = function() {
browser()
# equalWeights <- numeric(latentNodeLength, 1/latentNodeLength, TRUE)
# ids <- integer(leaveOutNumber, 0)
#
# rankSample(equalWeights, leaveOutNumber, ids, TRUE)
randomInt <- ceiling(runif(1, 0, numberOfLeaveOutOptions))
leaveOutNowIndices <- leaveOutIndices[,randomInt]
regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
if(model[[indicatorNode]] == 1) regular_RW_sampler$run()
},
methods = list(
reset = function() {regular_RW_sampler$reset()}
))
MCMCdefs.opt2 <- list('nimbleOpt2' = quote({
customSpec <- configureMCMC(Rmodel)
customSpec$removeSamplers('phi', print=FALSE)
customSpec$removeSamplers('gamma', print=FALSE)
customSpec$removeSamplers('p', print=FALSE)
customSpec$removeSamplers('psi1', print=FALSE)
## happens to be all top nodes
zeroOneNodes <- Rmodel$getNodeNames(topOnly = TRUE)
for(zon in zeroOneNodes) customSpec$addSampler(target = zon,
type =
"RW_sampler_latentSubsamp",
print=FALSE)
customSpec
}))
mcmcConf <- configureMCMC(occ.R.model)
?addSampler
customSpec <- configureMCMC(Rmodel)
customSpec$removeSamplers('phi', print=FALSE)
customSpec$removeSamplers('gamma', print=FALSE)
customSpec$removeSamplers('p', print=FALSE)
customSpec$removeSamplers('psi1', print=FALSE)
## happens to be all top nodes
zeroOneNodes <- Rmodel$getNodeNames(topOnly = TRUE)
for(zon in zeroOneNodes) customSpec$addSampler(target = zon,
type =
"RW_sampler_latentSubsamp",
print=FALSE)
MCMCdefs.opt2
MCMCdefs.opt2$nimbleOpt2
eval(MCMCdefs.opt2$nimbleOpt2)
input1$constants
?sample
leaveOutIndices <- sapply(1:100, sample(1:input1$constants$nsite, .8*input1$constants$nsite))
leaveOutIndices <- sapply(1:100, function(i){sample(1:input1$constants$nsite, .8*input1$constants$nsite)})
leaveOutIndices
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1), leaveOutIndices)
RW_sampler_latentSubsamp <- nimbleFunction(
contains = sampler_BASE,
setup = function(model, mvSaved, target, control, leaveOutIndices) {
regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
latentNodes <- control$latentNodes
leaveOutIndex <- control$leaveOutIndex
# leaveOutProportion <- control$leaveOutProportion
latentNodeLength <- nimDim(model[[latentNodes]])[leaveOutIndex]
leaveOutNumber <- floor(leaveOutProportion*latentNodeLength)
numberOfLeaveOutOptions <- dim(leaveOutIndices)[2]
},
run = function() {
browser()
# equalWeights <- numeric(latentNodeLength, 1/latentNodeLength, TRUE)
# ids <- integer(leaveOutNumber, 0)
#
# rankSample(equalWeights, leaveOutNumber, ids, TRUE)
randomInt <- ceiling(runif(1, 0, numberOfLeaveOutOptions))
leaveOutNowIndices <- leaveOutIndices[,randomInt]
regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
if(model[[indicatorNode]] == 1) regular_RW_sampler$run()
},
methods = list(
reset = function() {regular_RW_sampler$reset()}
))
RW_sampler_latentSubsamp <- nimbleFunction(
contains = sampler_BASE,
setup = function(model, mvSaved, target, control, leaveOutIndices) {
regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
latentNodes <- control$latentNodes
leaveOutIndex <- control$leaveOutIndex
# leaveOutProportion <- control$leaveOutProportion
latentNodeLength <- nimDim(model[[latentNodes]])[leaveOutIndex]
leaveOutNumber <- floor(leaveOutProportion*latentNodeLength)
numberOfLeaveOutOptions <- dim(leaveOutIndices)[2]
},
run = function() {
browser()
# equalWeights <- numeric(latentNodeLength, 1/latentNodeLength, TRUE)
# ids <- integer(leaveOutNumber, 0)
#
# rankSample(equalWeights, leaveOutNumber, ids, TRUE)
randomInt <- ceiling(runif(1, 0, numberOfLeaveOutOptions))
leaveOutNowIndices <- leaveOutIndices[,randomInt]
if(model[[indicatorNode]] == 1) regular_RW_sampler$run()
},
methods = list(
reset = function() {regular_RW_sampler$reset()}
))
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1), leaveOutIndices)
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list()), leaveOutIndices)
newMCMC <- buildMCMC(mcmcConf)
RW_sampler_latentSubsamp <- nimbleFunction(
contains = sampler_BASE,
setup = function(model, mvSaved, target, control, leaveOutIndices) {
# regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
latentNodes <- control$latentNodes
leaveOutIndex <- control$leaveOutIndex
# leaveOutProportion <- control$leaveOutProportion
latentNodeLength <- nimDim(model[[latentNodes]])[leaveOutIndex]
leaveOutNumber <- floor(leaveOutProportion*latentNodeLength)
numberOfLeaveOutOptions <- dim(leaveOutIndices)[2]
},
run = function() {
browser()
# equalWeights <- numeric(latentNodeLength, 1/latentNodeLength, TRUE)
# ids <- integer(leaveOutNumber, 0)
#
# rankSample(equalWeights, leaveOutNumber, ids, TRUE)
randomInt <- ceiling(runif(1, 0, numberOfLeaveOutOptions))
leaveOutNowIndices <- leaveOutIndices[,randomInt]
if(model[[indicatorNode]] == 1) regular_RW_sampler$run()
},
methods = list(
reset = function() {regular_RW_sampler$reset()}
))
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list()), leaveOutIndices)
newMCMC <- buildMCMC(mcmcConf)
occ.R.model <- nimbleModel(code=ss.ms.occ,
constants=input1$constants,
data=input1$data,
inits=input1$inits,
check=FALSE)
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list()), leaveOutIndices)
newMCMC <- buildMCMC(mcmcConf)
RW_sampler_latentSubsamp <- nimbleFunction(
contains = sampler_BASE,
setup = function(model, mvSaved, target, control, leaveOutIndices) {
# regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
latentNodes <- control$latentNodes
leaveOutIndex <- control$leaveOutIndex
# leaveOutProportion <- control$leaveOutProportion
latentNodeLength <- nimDim(model[[latentNodes]])[leaveOutIndex]
# leaveOutNumber <- floor(leaveOutProportion*latentNodeLength)
numberOfLeaveOutOptions <- dim(leaveOutIndices)[2]
},
run = function() {
browser()
# equalWeights <- numeric(latentNodeLength, 1/latentNodeLength, TRUE)
# ids <- integer(leaveOutNumber, 0)
#
# rankSample(equalWeights, leaveOutNumber, ids, TRUE)
randomInt <- ceiling(runif(1, 0, numberOfLeaveOutOptions))
leaveOutNowIndices <- leaveOutIndices[,randomInt]
if(model[[indicatorNode]] == 1) regular_RW_sampler$run()
},
methods = list(
reset = function() {regular_RW_sampler$reset()}
))
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list()), leaveOutIndices)
newMCMC <- buildMCMC(mcmcConf)
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list()),
leaveOutIndices =  leaveOutIndices)
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list(),
RW_sampler_latentSubsamp <- nimbleFunction(
contains = sampler_BASE,
setup = function(model, mvSaved, target, control) {
# regular_RW_sampler <- sampler_RW(model, mvSaved, target = target, control = control$control)
latentNodes <- control$latentNodes
leaveOutIndex <- control$leaveOutIndex
leaveOutIndices <- control$leaveOutIndices
# leaveOutProportion <- control$leaveOutProportion
latentNodeLength <- nimDim(model[[latentNodes]])[leaveOutIndex]
# leaveOutNumber <- floor(leaveOutProportion*latentNodeLength)
numberOfLeaveOutOptions <- dim(leaveOutIndices)[2]
},
run = function() {
browser()
# equalWeights <- numeric(latentNodeLength, 1/latentNodeLength, TRUE)
# ids <- integer(leaveOutNumber, 0)
#
# rankSample(equalWeights, leaveOutNumber, ids, TRUE)
randomInt <- ceiling(runif(1, 0, numberOfLeaveOutOptions))
leaveOutNowIndices <- leaveOutIndices[,randomInt]
if(model[[indicatorNode]] == 1) regular_RW_sampler$run()
},
methods = list(
reset = function() {regular_RW_sampler$reset()}
))
mcmcConf <- configureMCMC(occ.R.model)
mcmcConf$addSampler('psi1', type = "RW_sampler_latentSubsamp", control = list(latentNodes = 'z', leaveOutIndex = 1, control = list(),
leaveOutIndices =  leaveOutIndices))
newMCMC <- buildMCMC(mcmcConf)
newMCMC$run(1)
