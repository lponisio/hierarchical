rm(list=ls())#
library(nimble)#
library(parallel)#
options(mc.cores=1)#
nthin <- 2#
#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=pumpCode,#
                       constants=pumpConsts,#
                       data=pumpData,#
                       inits=pumpInits,#
                       check=FALSE)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=nthin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
D.model <- compileNimble(R.model)#
D.mcmc <- compileNimble(mcmc, project = R.model)#
D.mcmc$run(10000)#
message('NIMBLE model compiled')#
#
source('~/Dropbox/nimble/occupancy/analysis/cppp/src/calcCPPP.R')#
set.seed(4)#
#
output <- generateCPPP(R.model,#
                       D.model,#
                       D.mcmc,#
                       mcmc,#
                       dataNames = 'x',#
                       paramNames = c('alpha','beta'), #
                       NpostSamp = 100,#
                       NPDist = 100,#
                       burnInProp = 0.1,#
                       thin = nthin,#
                       averageParams = TRUE,#
                       nRepBoot=100,#
                       discFuncGenerator=likeDiscFuncGenerator)
output$cppp
output$chain.diagnostic
names(output)
plot(density(output$sim.cpp.dist))
output$samples[[94]]
summary(output$samples[[94]])
rm(list=ls())#
library(nimble)#
library(parallel)#
options(mc.cores=1)#
nthin <- 2#
#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dnorm(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=pumpCode,#
                       constants=pumpConsts,#
                       data=pumpData,#
                       inits=pumpInits,#
                       check=FALSE)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=nthin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
D.model <- compileNimble(R.model)#
D.mcmc <- compileNimble(mcmc, project = R.model)#
D.mcmc$run(10000)#
message('NIMBLE model compiled')#
#
source('~/Dropbox/nimble/occupancy/analysis/cppp/src/calcCPPP.R')#
set.seed(4)#
#
output <- generateCPPP(R.model,#
                       D.model,#
                       D.mcmc,#
                       mcmc,#
                       dataNames = 'x',#
                       paramNames = c('alpha','beta'), #
                       NpostSamp = 100,#
                       NPDist = 100,#
                       burnInProp = 0.1,#
                       thin = nthin,#
                       averageParams = TRUE,#
                       nRepBoot=100,#
                       discFuncGenerator=likeDiscFuncGenerator)
output$cppp
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  prep.cov[1:nsite, 1:nsite] <- mexp(-delta*D[1:nsite, 1:nsite])#
   D.cov[[1:nsite, 1:nsite]] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  prep.cov[1:nsite, 1:nsite] <- mexp(-delta*D[1:nsite, 1:nsite])#
   D.cov[1:nsite, 1:nsite] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  dist.mat <- -delta*D[1:nsite, 1:nsite]#
  prep.cov[1:nsite, 1:nsite] <- mexp(dist.mat)#
   D.cov[1:nsite, 1:nsite] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  dist.mat[1:nsite, 1:nsite] <- -delta*D[1:nsite, 1:nsite]#
  prep.cov[1:nsite, 1:nsite] <- mexp(dist.mat)#
   D.cov[1:nsite, 1:nsite] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  dist.mat[1:nsite, 1:nsite] <- -delta*D[1:nsite, 1:nsite]#
  prep.cov[1:nsite, 1:nsite] <- mexp(dist.mat[1:nsite, 1:nsite])#
   D.cov[1:nsite, 1:nsite] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- inverse(D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  dist.mat[1:nsite, 1:nsite] <- -delta*D[1:nsite, 1:nsite]#
  prep.cov[1:nsite, 1:nsite] <- mexp(dist.mat[1:nsite, 1:nsite])#
   D.cov[1:nsite, 1:nsite] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- inverse(prep.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
rm(list=ls())#
setwd("~/Dropbox/nimble/occupancy/analysis/spatial")#
source('src/initialize.R')#
library(rjags)#
load.module("msm")#
#
set.seed(444)#
dats <- genSpatialOccData()#
model.input <- prepModData(dats$data, dats$y, dats$distance,#
                           nsite=250, inits=dats$inits)#
#
mexp <- nimbleFunction(#
  run = function(A = double(2)){#
    returnType(double(2))#
    outMat <- exp(A)#
    return(outMat)#
  })#
#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0.1, 10)#
  sigma ~ dunif(0.1, 10)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  rho[1:nsite] ~ dmnorm(zeros[1:nsite],#
                        D.tau[1:nsite, 1:nsite])#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:nsite) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection#
    ## observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  ## create covariance matrix based on distances (must be 1/cov for#
  ## JAGS)#
#
  ## mexp is jags's version fo matrix exponentiation, very sensitive#
  dist.mat[1:nsite, 1:nsite] <- -delta*D[1:nsite, 1:nsite]#
  prep.cov[1:nsite, 1:nsite] <- mexp(dist.mat[1:nsite, 1:nsite])#
   D.cov[1:nsite, 1:nsite] <- (sigma^2)*(0.95*prep.cov[1:nsite, 1:nsite] + 0.05*DI[1:nsite, 1:nsite])#
#
  ##   for(i in 1:nsite){#
  ##   for(j in 1:nsite){#
  ##     prep.cov[i, j]  <- exp(-delta*D[i, j])#
  ##     D.cov[i, j] <- (sigma^2)*(0.95*prep.cov[i, j] + 0.05*DI[i, j])#
  ##   }#
  ## }#
  D.tau[1:nsite, 1:nsite] <- (D.cov[1:nsite, 1:nsite])#
})#
input1 <- c(code=sp.mod,#
            model.input)#
#
## *********************************************************************#
## opt 1:vanilla nimble and auto block#
## *********************************************************************#
#
sp.orig <- compareMCMCs(input1,#
                        MCMCs=c("jags"),#
                        niter=niter,#
                        burnin = burnin,#
                        summary=FALSE,#
                        check=FALSE)#
#
save(sp.orig, file=file.path(save.dir, "orig.Rdata"))
