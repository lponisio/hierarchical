rm(list=ls()) #
setwd('~/Dropbox/nimble/occupancy/analysis/multiSpp-singleSea')#
#
source('src/initialize.R')#
## don't agument data#
n.zeroes <- 0#
model.input <- prepMutiSpData(survey.data,#
                              survey.dates,#
                              species.groups,#
                              habitat,#
                              n.zeros)#
#
## *********************************************************************#
## multi-species site-occupancy models: vectorized with custom#
## function to remove zs#
## *********************************************************************#
#
ms.ss.occ <- nimbleCode({#
  ## Define prior distributions for community-level model parameters#
  cato.occ.mean ~ dunif(0,1)#
  mu.ucato <- log(cato.occ.mean) - log(1-cato.occ.mean)#
#
  fcw.occ.mean ~ dunif(0,1)#
  mu.ufcw <- log(fcw.occ.mean) - log(1-fcw.occ.mean)#
#
  cato.det.mean ~ dunif(0,1)#
  mu.vcato <- log(cato.det.mean) - log(1-cato.det.mean)#
#
  fcw.det.mean ~ dunif(0,1)#
  mu.vfcw <- log(fcw.det.mean) - log(1-fcw.det.mean)#
#
  ## random effects#
  sigma.ucato ~ dunif(0, 100)#
  sigma.ufcw ~ dunif(0, 100)#
  mu.a1 ~ dnorm(0, 0.001)#
  sigma.a1 ~ dunif(0, 100)#
  mu.a2 ~ dnorm(0, 0.001)#
  sigma.a2 ~ dunif(0, 100)#
  mu.a3 ~ dnorm(0, 0.001)#
  sigma.a3 ~ dunif(0, 100)#
  mu.a4 ~ dnorm(0, 0.001)#
  sigma.a4 ~ dunif(0, 100)#
#
  sigma.vcato ~ dunif(0, 100)#
  sigma.vfcw ~ dunif(0, 100)#
  mu.b1 ~ dnorm(0, 0.001)#
  sigma.b1 ~ dunif(0, 100)#
  mu.b2 ~ dnorm(0, 0.001)#
  sigma.b2 ~ dunif(0, 100)#
  for (i in 1:(num.species)) {#
    ## Create priors for species i from the community level prior#
    ## distributions#
#
    u.cato[i] ~ dnorm(mu.ucato, sd=sigma.ucato)#
    u.fcw[i] ~ dnorm(mu.ufcw, sd=sigma.ufcw)#
    a1[i] ~ dnorm(mu.a1, sd=sigma.a1)#
    a2[i] ~ dnorm(mu.a2, sd=sigma.a2)#
    a3[i] ~ dnorm(mu.a3, sd=sigma.a3)#
    a4[i] ~ dnorm(mu.a4, sd=sigma.a4)#
#
    v.cato[i] ~ dnorm(mu.vcato, sd=sigma.vcato)#
    v.fcw[i] ~ dnorm(mu.vfcw, sd=sigma.vfcw)#
    b1[i] ~ dnorm(mu.b1, sd=sigma.b1)#
    b2[i] ~ dnorm(mu.b2, sd=sigma.b2)#
#
    ## vectorize the calculation of psi.#
    logit(psi[1:num.points,i]) <-#
      u.cato[i]*(1-habitat.ind[1:num.points]) +#
        u.fcw[i]*habitat.ind[1:num.points] +#
          a1[i]*ufc.linear[1:num.points] +#
            a2[i]*ufc.quadratic[1:num.points] +#
              a3[i]*ba.linear[1:num.points] +#
                a4[i]*ba.quadratic[1:num.points]#
    ## vectorized calculation#
    mu.psi[1:num.points,i] <- psi[1:num.points, i]#
#
    ## For our purpose a better way to write this way is to#
    ## not worry that some elements of date.linear and date.quadratic#
    ## aren't used, since the benefit of vectorizing the computation#
    ## should be much greater than the cost of a few extra elements#
    logit(p[1:num.points, 1:max.num.reps, i]) <-#
      (v.cato[i]*(1-habitat.ind[1:num.points]) +#
       v.fcw[i]*habitat.ind[1:num.points]) %*%#
         asRow(onesRow[1, 1:max.num.reps])+#
           b1[i]*date.linear[1:num.points,1:max.num.reps] +#
             b2[i]*date.quadratic[1:num.points,1:max.num.reps]#
#
    ## user defined distribution to combine the bernoulli occupancy#
    ## and detection events.  We can also make this is a single#
    ## compuation for the entire matrix of locations-x-visits, for#
    ## each species (i)#
    X[1:num.points, 1:max.num.reps, i] ~ dBernDetectionMatrix(#
      occProb = mu.psi[1:num.points,i],#
      detectionProb = p[1:num.points, 1:max.num.reps,i],#
      numReps = num.reps[1:num.points])#
  }#
  ## Derived quantities:#
  ## for(j in 1:num.points){#
  ##   N.site[j]<- sum(mu.psi[j,1:(num.species)])#
  ##   N.ground[j]<- sum(mu.psi[j,1:num.species] * ground[1:num.species])#
  ##   N.mid[j]<- sum(mu.psi[j,1:num.species] * mid[1:num.species])#
  ## }#
})#
input1 <- c(code=ms.ss.occ, model.input)
## *********************************************************************#
## ## cross validation#
## *********************************************************************#
## if not already run above#
occ.R.model <- nimbleModel(code=ms.ss.occ,#
                           constants=input1$constants,#
                           data=input1$data,#
                           inits=input1$inits,#
                           check=FALSE)#
#
niter <- 10#
options(mc.cores=1)
source('../crossValidation/crossValidationFunction.R')#
#
output <- crossValidateOne(model=occ.R.model,#
                           dataNames= "X",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=3,#
                           MCMCdefs=NULL)
source('../crossValidation/crossValidationFunction.R')#
#
output <- crossValidateOne(model=occ.R.model,#
                           dataNames= "X",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=3,#
                           MCMCdefs=NULL)
niter <- 2#
options(mc.cores=1)#
#
source('../crossValidation/crossValidationFunction.R')#
#
output <- crossValidateOne(model=occ.R.model,#
                           dataNames= "X",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=3,#
                           MCMCdefs=NULL)
