library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
#
generateCPPP <-  function(code, ## model created by nimbleCode()#
                          constants,#
                          data,#
                          dataName,#
                          inits, ## inital values for parameters to estimate#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
#
  ## build model#
  R.model <- nimbleModel(code=code,#
                         constants=constants,#
                         data=data,#
                         inits=inits,#
                         check=FALSE,...)#
  message('R model created')#
  ## configure and build mcmc#
  mcmc.spec <- configureMCMC(R.model,#
                             print=FALSE,#
                             monitors = paramNames,#
                             thin=thin)#
  mcmc <- buildMCMC(mcmc.spec)#
  message('MCMC built')#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(R.model, dataName,#
                          paramNames, mcmcMV,#
                          MCMCIter, thin)#
  ## compile model in C++#
  C.model <- compileNimble(R.model)#
  C.mcmc <- compileNimble(mcmc, project = R.model)#
  C.pppFunc <- compileNimble(modelpppFunc, project = R.model)#
  paramDependencies <- C.model$getDependencies(paramNames)#
  message('NIMBLE model compiled')#
#
  ## run model#
  print('running model')#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(code=pumpCode,#
             constants =pumpConsts,#
             data = pumpData,#
             dataName = 'x',#
             inits = pumpInits, #
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = 2)
library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
#
generateCPPP <-  function(code, ## model created by nimbleCode()#
                          constants,#
                          data,#
                          dataName,#
                          inits, ## inital values for parameters to estimate#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  ## build model#
  R.model <- nimbleModel(code=code,#
                         constants=constants,#
                         data=data,#
                         inits=inits,#
                         check=FALSE,...)#
  message('R model created')#
  ## configure and build mcmc#
  mcmc.spec <- configureMCMC(R.model,#
                             print=FALSE,#
                             monitors = paramNames,#
                             thin=thin)#
  mcmc <- buildMCMC(mcmc.spec)#
  message('MCMC built')#
  ## compile model in C++#
  C.model <- compileNimble(R.model)#
  C.mcmc <- compileNimble(mcmc, project = R.model)#
  C.pppFunc <- compileNimble(modelpppFunc, project = R.model)#
  paramDependencies <- C.model$getDependencies(paramNames)#
  message('NIMBLE model compiled')#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(R.model, dataName,#
                          paramNames, mcmcMV,#
                          MCMCIter, thin)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(code=pumpCode,#
             constants =pumpConsts,#
             data = pumpData,#
             dataName = 'x',#
             inits = pumpInits, #
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = 2)
library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
#
generateCPPP <-  function(code, ## model created by nimbleCode()#
                          constants,#
                          data,#
                          dataName,#
                          inits, ## inital values for parameters to estimate#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  ## build model#
  R.model <- nimbleModel(code=code,#
                         constants=constants,#
                         data=data,#
                         inits=inits,#
                         check=FALSE,...)#
  message('R model created')#
  ## configure and build mcmc#
  mcmc.spec <- configureMCMC(R.model,#
                             print=FALSE,#
                             monitors = paramNames,#
                             thin=thin)#
  mcmc <- buildMCMC(mcmc.spec)#
  message('MCMC built')#
  ## compile model in C++#
  C.model <- compileNimble(R.model)#
  C.mcmc <- compileNimble(mcmc, project = R.model)#
  message('NIMBLE model compiled')#
#
  paramDependencies <- C.model$getDependencies(paramNames)#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(R.model, dataName,#
                          paramNames, mcmcMV,#
                          MCMCIter, thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = R.model)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(code=pumpCode,#
             constants =pumpConsts,#
             data = pumpData,#
             dataName = 'x',#
             inits = pumpInits, #
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = 2)
library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=code,#
                       constants=constants,#
                       data=data,#
                       inits=inits,#
                       check=FALSE,...)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = paramNames,#
                           thin=thin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
C.model <- compileNimble(R.model)#
C.mcmc <- compileNimble(mcmc, project = R.model)#
message('NIMBLE model compiled')#
generateCPPP <-  function(C.model,#
                          C.mcmc,#
                          mcmc,#
                          dataName,#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  paramDependencies <- C.model$getDependencies(paramNames)#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(C.model,#
                          dataName,#
                          paramNames,#
                          mcmcMV,#
                          MCMCIter,#
                          thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = C.model)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = 2)
library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=code,#
                       constants=constants,#
                       data=data,#
                       inits=inits,#
                       check=FALSE,...)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = paramNames,#
                           thin=thin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
C.model <- compileNimble(R.model)#
C.mcmc <- compileNimble(mcmc, project = R.model)#
message('NIMBLE model compiled')
library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=code,#
                       constants=constants,#
                       data=data,#
                       inits=inits,#
                       check=FALSE)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = paramNames,#
                           thin=thin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
C.model <- compileNimble(R.model)#
C.mcmc <- compileNimble(mcmc, project = R.model)#
message('NIMBLE model compiled')#
generateCPPP <-  function(C.model,#
                          C.mcmc,#
                          mcmc,#
                          dataName,#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  paramDependencies <- C.model$getDependencies(paramNames)#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(C.model,#
                          dataName,#
                          paramNames,#
                          mcmcMV,#
                          MCMCIter,#
                          thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = C.model)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = 2)
library(nimble)#
library(parallel)#
options(mc.cores=2)#
#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))
## build model#
R.model <- nimbleModel(code=code,#
                       constants=constants,#
                       data=data,#
                       inits=inits,#
                       check=FALSE)#
message('R model created')
## build model#
R.model <- nimbleModel(code=pumpCode,#
                       constants=pumpConstants,#
                       data=pumpData,#
                       inits=pumpInits,#
                       check=FALSE)#
message('R model created')
## build model#
R.model <- nimbleModel(code=pumpCode,#
                       constants=pumpConsts,#
                       data=pumpData,#
                       inits=pumpInits,#
                       check=FALSE)#
message('R model created')
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=thin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=nthin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')
nthin <- 2
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=nthin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')
C.model <- compileNimble(R.model)#
C.mcmc <- compileNimble(mcmc, project = R.model)
generateCPPP <-  function(C.model,#
                          C.mcmc,#
                          mcmc,#
                          dataName,#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  paramDependencies <- C.model$getDependencies(paramNames)#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(C.model,#
                          dataName,#
                          paramNames,#
                          mcmcMV,#
                          MCMCIter,#
                          thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = C.model)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = nthin)
generateCPPP <-  function(R.model,#
                          C.model,#
                          C.mcmc,#
                          mcmc,#
                          dataName,#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  paramDependencies <- C.model$getDependencies(paramNames)#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(C.model,#
                          dataName,#
                          paramNames,#
                          mcmcMV,#
                          MCMCIter,#
                          thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = R.model)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(R.model,#
             C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = nthin)
generateCPPP <-  function(R.model,#
                          C.model,#
                          C.mcmc,#
                          mcmc,#
                          dataName,#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  paramDependencies <- C.model$getDependencies(paramNames)#
#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(R.model,#
                          dataName,#
                          paramNames,#
                          mcmcMV,#
                          MCMCIter,#
                          thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = R.model)#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(R.model,#
             C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 10,#
             thin = nthin)
generateCPPP(R.model,#
             C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 100,#
             thin = nthin)
library(nimble)#
library(parallel)#
options(mc.cores=2)#
nthin <- 2#
#
## draws a random number from the posterior, reassigned it as the#
## paramter value, simulates data from the model#
pppFunc <- nimbleFunction(#
  setup = function(model, dataName, paramNames, MCMCmv, MCMCIter, thin){#
    paramDependencies <- model$getDependencies(paramNames)#
  },#
  run = function(N = integer(0)){#
    deviances <- numeric(N)#
    for(i in 1:N){#
      randNum <- ceiling(runif(1, 0, MCMCIter/thin -1 ))#
      nimCopy(MCMCmv, model, paramNames, row = randNum)#
      calculate(model, paramDependencies)#
      simulate(model, dataName)#
      deviances[i] <- calculate(model)#
    }#
    return(deviances)#
    returnType(double(1))#
  }#
  )#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=pumpCode,#
                       constants=pumpConsts,#
                       data=pumpData,#
                       inits=pumpInits,#
                       check=FALSE)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=nthin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
C.model <- compileNimble(R.model)#
C.mcmc <- compileNimble(mcmc, project = R.model)#
message('NIMBLE model compiled')#
generateCPPP <-  function(R.model,#
                          C.model,#
                          C.mcmc,#
                          mcmc,#
                          dataName,#
                          paramNames, ## vector of parameters to monitor#
                          MCMCIter, ## number of samples#
                          NSamp,#
                          NPDist,#
                          thin,...){#
  ## calculate proportion of deviances that are greater or equal to#
  ## the observed value#
  calcCPPP <- function(MCMCIter, C.model, NSamp,#
                       C.pppFunc, C.mcmc){#
#
    C.mcmc$run(MCMCIter)  #
    observedDisc <- calculate(C.model)  #
    otherDiscs <- C.pppFunc$run(NSamp)#
    pre.pp <- mean(otherDiscs >= observedDisc)#
    return(pre.pp)    #
  }#
#
  ## simulate the distribution of posterior predictive pvalues#
  simPppDist <- function(interation,#
                         MCMCIter,#
                         C.mcmc,#
                         C.model,#
                         paramNames,#
                         paramDependencies,#
                         NSamp, thin){#
    randNum <- ceiling(runif(1, 0, MCMCIter/thin - 1))#
    mcmc.samples <- as.matrix(C.mcmc$mvSamples)#
    values(C.model, paramNames) <- mcmc.samples[randNum,]#
    calculate(C.model, paramDependencies)#
    simulate(C.model, dataName)#
    out <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
    return(out)#
  }#
#
  ## sample posterior, simulate data from sample #
  paramDependencies <- C.model$getDependencies(paramNames)#
  mcmcMV <- mcmc$mvSamples#
  modelpppFunc <- pppFunc(R.model,#
                          dataName,#
                          paramNames,#
                          mcmcMV,#
                          MCMCIter,#
                          thin)#
#
  C.pppFunc <- compileNimble(modelpppFunc, project = R.model)#
#
  ## calculate deviances#
  obs.cppp <- calcCPPP(MCMCIter, C.model, NSamp, C.pppFunc, C.mcmc)#
#
  ## refits model with sampled data, reruns, enter inner loop,#
  ## calculates distbution of PPPs#
  sim.cppp <- unlist(mclapply(1:NPDist, simPppDist,#
                              MCMCIter,#
                              C.mcmc,#
                              C.model,#
                              paramNames,#
                              paramDependencies,#
                              NSamp,#
                              thin))#
  ## calculates the number of simulated ppp that fall below the obs#
  out.cppp <- mean(obs.cppp <= sim.cppp)  #
  return(list(cppp=out.cppp,#
              obs=obs.cppp,#
              sim=sim.cppp))#
}#
#
generateCPPP(R.model,#
             C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 100,#
             thin = nthin)
rm(list=ls())#
library(nimble)#
library(parallel)#
options(mc.cores=2)#
nthin <- 2#
source('~/Dropbox/occupancy-nimble/cppp/src/calcCPPP.R')#
pumpCode <- nimbleCode({#
  for (i in 1:N){#
    theta[i] ~ dgamma(alpha,beta)#
    lambda[i] <- theta[i]*t[i]#
    x[i] ~ dpois(lambda[i])#
  }#
  alpha ~ dexp(1.0)#
  beta ~ dgamma(0.1,1.0)#
})#
#
pumpConsts <- list(N = 10,#
                   t = c(94.3, 15.7, 62.9, 126, 5.24,#
                     31.4, 1.05, 1.05, 2.1, 10.5))#
pumpData <- list(x = c(5, 1, 5, 14, 3, 19, 1, 1, 4, 22))#
pumpInits <- list(alpha = 1, beta = 1,#
                  theta = rep(0.1, pumpConsts$N))#
## build model#
R.model <- nimbleModel(code=pumpCode,#
                       constants=pumpConsts,#
                       data=pumpData,#
                       inits=pumpInits,#
                       check=FALSE)#
message('R model created')#
#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = c("alpha", "beta"),#
                           thin=nthin)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')#
#
## compile model in C++#
C.model <- compileNimble(R.model)#
C.mcmc <- compileNimble(mcmc, project = R.model)#
message('NIMBLE model compiled')#
#
generateCPPP(R.model,#
             C.model,#
             C.mcmc,#
             mcmc,#
             dataName = 'x',#
             paramNames = c('alpha','beta'), #
             MCMCIter = 1000, #
             NSamp = 1000,#
             NPDist = 100,#
             thin = nthin)
rm(list=ls())#
setwd("~/Dropbox/occupancy-nimble/singleSpp-multiSea")#
source('src/initialize.R')#
#
## *********************************************************************#
##  Multi-season occupancy model: option 4-5 remove latent states using#
##  user-defined NIMBLE function#
##  *********************************************************************#
#
## Specify model in NIMBLE#
ss.ms.occ <- nimbleCode({#
  ##  priors#
  psi1 ~ dunif(0, 1)#
#
  for(k in 1:(nyear-1)){#
    phi[k] ~ dunif(0, 1)#
    gamma[k] ~ dunif(0, 1)#
    p[k] ~ dunif(0, 1)#
  }#
  p[nyear] ~ dunif(0, 1)#
#
  ## Ecological submodel: Define state conditional on parameters#
  for(i in 1:nsite) {#
    ## removes the z's and muZ's from the model and compute#
    ## the probability of all reps over all years for one site.#
    y[i, 1:nrep, 1:nyear] ~ dDynamicOccupancy(nrep,#
                                              psi1,#
                                              phi[1:(nyear-1)],#
                                              gamma[1:(nyear-1)],#
                                              p[1:nyear])#
  }#
#
  ## Derived parameters: Sample and population occupancy, growth rate#
  ## and turnover#
  psi[1] <- psi1#
  n.occ[1]<- sum(z[1:nsite,1])#
  for (k in 2:nyear){#
    psi[k] <- psi[k-1]*phi[k-1] + (1-psi[k-1])*gamma[k-1]#
    n.occ[k] <- sum(z[1:nsite,k])#
    growthr[k-1] <- psi[k]/psi[k-1]#
    turnover[k-1] <- (1 - psi[k-1]) * gamma[k-1]/psi[k]#
  }#
})#
#
## *********************************************************************#
## opt 4 run with compareMCMCs#
## *********************************************************************#
#
input1 <- list(code=ss.ms.occ,#
               constants=constants,#
               data=model.data,#
               inits=inits)
## build model#
R.model <- nimbleModel(code=ss.ms.occ,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits,#
                       check=FALSE)#
message('R model created')
ls()
## build model#
R.model <- nimbleModel(code=ss.ms.occ,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits,#
                       check=FALSE)#
message('R model created')#
## configure and build mcmc#
mcmc.spec <- configureMCMC(R.model,#
                           print=FALSE,#
                           monitors = monitors,#
                           thin=1)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')
## configure and build mcmc#
mcmc.spec <- configureMCMC(ss.ms.occ,#
                           print=FALSE,#
                           monitors = monitors,#
                           thin=1)#
mcmc <- buildMCMC(mcmc.spec)#
message('MCMC built')
## *********************************************************************#
#
## build model#
R.model <- nimbleModel(code=ss.ms.occ,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits,#
                       check=FALSE)#
message('R model created')
ss.ms.opt4 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)
rm(list=ls())#
setwd("~/Dropbox/occupancy-nimble/singleSpp-multiSea")#
source('src/initialize.R')#
#
## *********************************************************************#
##  Multi-season occupancy model: option 4-5 remove latent states using#
##  user-defined NIMBLE function#
##  *********************************************************************#
#
## Specify model in NIMBLE#
ss.ms.occ <- nimbleCode({#
  ##  priors#
  psi1 ~ dunif(0, 1)#
#
  for(k in 1:(nyear-1)){#
    phi[k] ~ dunif(0, 1)#
    gamma[k] ~ dunif(0, 1)#
    p[k] ~ dunif(0, 1)#
  }#
  p[nyear] ~ dunif(0, 1)#
#
  ## Ecological submodel: Define state conditional on parameters#
  for(i in 1:nsite) {#
    ## removes the z's and muZ's from the model and compute#
    ## the probability of all reps over all years for one site.#
    y[i, 1:nrep, 1:nyear] ~ dDynamicOccupancy(nrep,#
                                              psi1,#
                                              phi[1:(nyear-1)],#
                                              gamma[1:(nyear-1)],#
                                              p[1:nyear])#
  }#
#
  ## Derived parameters: Sample and population occupancy, growth rate#
  ## and turnover#
  psi[1] <- psi1#
  n.occ[1]<- sum(z[1:nsite,1])#
  for (k in 2:nyear){#
    psi[k] <- psi[k-1]*phi[k-1] + (1-psi[k-1])*gamma[k-1]#
    n.occ[k] <- sum(z[1:nsite,k])#
    growthr[k-1] <- psi[k]/psi[k-1]#
    turnover[k-1] <- (1 - psi[k-1]) * gamma[k-1]/psi[k]#
  }#
})#
#
## *********************************************************************#
## opt 4 run with compareMCMCs#
## *********************************************************************#
#
input1 <- list(code=ss.ms.occ,#
               constants=constants,#
               data=model.data,#
               inits=inits)#
#
monitors <- c("phi", "gamma", "psi")#
#
ss.ms.opt4 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)#
#
save(ss.ms.opt4, file="saved/opt4.Rdata")
install.packages("nimble")
rm(list=ls())#
setwd("~/Dropbox/occupancy-nimble/singleSpp-multiSea")#
source('src/initialize.R')#
#
## *********************************************************************#
##  Multi-season occupancy model: option 4-5 remove latent states using#
##  user-defined NIMBLE function#
##  *********************************************************************#
#
## Specify model in NIMBLE#
ss.ms.occ <- nimbleCode({#
  ##  priors#
  psi1 ~ dunif(0, 1)#
#
  for(k in 1:(nyear-1)){#
    phi[k] ~ dunif(0, 1)#
    gamma[k] ~ dunif(0, 1)#
    p[k] ~ dunif(0, 1)#
  }#
  p[nyear] ~ dunif(0, 1)#
#
  ## Ecological submodel: Define state conditional on parameters#
  for(i in 1:nsite) {#
    ## removes the z's and muZ's from the model and compute#
    ## the probability of all reps over all years for one site.#
    y[i, 1:nrep, 1:nyear] ~ dDynamicOccupancy(nrep,#
                                              psi1,#
                                              phi[1:(nyear-1)],#
                                              gamma[1:(nyear-1)],#
                                              p[1:nyear])#
  }#
#
  ## Derived parameters: Sample and population occupancy, growth rate#
  ## and turnover#
  psi[1] <- psi1#
  n.occ[1]<- sum(z[1:nsite,1])#
  for (k in 2:nyear){#
    psi[k] <- psi[k-1]*phi[k-1] + (1-psi[k-1])*gamma[k-1]#
    n.occ[k] <- sum(z[1:nsite,k])#
    growthr[k-1] <- psi[k]/psi[k-1]#
    turnover[k-1] <- (1 - psi[k-1]) * gamma[k-1]/psi[k]#
  }#
})#
#
## *********************************************************************#
## opt 4 run with compareMCMCs#
## *********************************************************************#
#
input1 <- list(code=ss.ms.occ,#
               constants=constants,#
               data=model.data,#
               inits=inits)#
#
monitors <- c("phi", "gamma", "psi")#
#
ss.ms.opt4 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)
install.packages("nimble")
install.packages("nimble")
install.packages("nimble", repos = "http://r-nimble.org", type = "source")
rm(list=ls())#
setwd("~/Dropbox/occupancy-nimble/singleSpp-multiSea")#
source('src/initialize.R')#
#
## *********************************************************************#
##  Multi-season occupancy model: option 4-5 remove latent states using#
##  user-defined NIMBLE function#
##  *********************************************************************#
#
## Specify model in NIMBLE#
ss.ms.occ <- nimbleCode({#
  ##  priors#
  psi1 ~ dunif(0, 1)#
#
  for(k in 1:(nyear-1)){#
    phi[k] ~ dunif(0, 1)#
    gamma[k] ~ dunif(0, 1)#
    p[k] ~ dunif(0, 1)#
  }#
  p[nyear] ~ dunif(0, 1)#
#
  ## Ecological submodel: Define state conditional on parameters#
  for(i in 1:nsite) {#
    ## removes the z's and muZ's from the model and compute#
    ## the probability of all reps over all years for one site.#
    y[i, 1:nrep, 1:nyear] ~ dDynamicOccupancy(nrep,#
                                              psi1,#
                                              phi[1:(nyear-1)],#
                                              gamma[1:(nyear-1)],#
                                              p[1:nyear])#
  }#
#
  ## Derived parameters: Sample and population occupancy, growth rate#
  ## and turnover#
  psi[1] <- psi1#
  n.occ[1]<- sum(z[1:nsite,1])#
  for (k in 2:nyear){#
    psi[k] <- psi[k-1]*phi[k-1] + (1-psi[k-1])*gamma[k-1]#
    n.occ[k] <- sum(z[1:nsite,k])#
    growthr[k-1] <- psi[k]/psi[k-1]#
    turnover[k-1] <- (1 - psi[k-1]) * gamma[k-1]/psi[k]#
  }#
})#
#
## *********************************************************************#
## opt 4 run with compareMCMCs#
## *********************************************************************#
#
input1 <- list(code=ss.ms.occ,#
               constants=constants,#
               data=model.data,#
               inits=inits)#
#
monitors <- c("phi", "gamma", "psi")#
#
ss.ms.opt4 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)#
#
save(ss.ms.opt4, file="saved/opt4.Rdata")
rm(list=ls())#
setwd("~/Dropbox/occupancy-nimble/singleSpp-multiSea")#
source('src/initialize.R')#
#
## *********************************************************************#
##  Multi-season occupancy model: option 4-5 remove latent states using#
##  user-defined NIMBLE function#
##  *********************************************************************#
#
## Specify model in NIMBLE#
ss.ms.occ <- nimbleCode({#
  ##  priors#
  psi1 ~ dunif(0, 1)#
#
  for(k in 1:(nyear-1)){#
    phi[k] ~ dunif(0, 1)#
    gamma[k] ~ dunif(0, 1)#
    p[k] ~ dunif(0, 1)#
  }#
  p[nyear] ~ dunif(0, 1)#
#
  ## Ecological submodel: Define state conditional on parameters#
  for(i in 1:nsite) {#
    ## removes the z's and muZ's from the model and compute#
    ## the probability of all reps over all years for one site.#
    y[i, 1:nrep, 1:nyear] ~ dDynamicOccupancy(nrep,#
                                              psi1,#
                                              phi[1:(nyear-1)],#
                                              gamma[1:(nyear-1)],#
                                              p[1:nyear])#
  }#
#
  ## Derived parameters: Sample and population occupancy, growth rate#
  ## and turnover#
  psi[1] <- psi1#
  n.occ[1]<- sum(z[1:nsite,1])#
  for (k in 2:nyear){#
    psi[k] <- psi[k-1]*phi[k-1] + (1-psi[k-1])*gamma[k-1]#
    n.occ[k] <- sum(z[1:nsite,k])#
    growthr[k-1] <- psi[k]/psi[k-1]#
    turnover[k-1] <- (1 - psi[k-1]) * gamma[k-1]/psi[k]#
  }#
})#
#
## *********************************************************************#
## opt 4 run with compareMCMCs#
## *********************************************************************#
#
input1 <- list(code=ss.ms.occ,#
               constants=constants,#
               data=model.data,#
               inits=inits)#
#
## monitors <- c("phi", "gamma", "psi")#
#
ss.ms.opt4 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)
rm(list=ls())#
setwd('~/Dropbox/occupancy-nimble/multiSpp-singleSea')#
#
## don't agument data#
n_zeroes <- 0#
source('src/initialize.R')#
#
## *********************************************************************#
## multi-species site-occupancy models: vectorized with custom#
## function to remove zs#
## *********************************************************************#
#
## Since calculations with date_linear and date_quadratic are now#
## vectorized, we'll set the NAs to 0#
model_data$date_linear[is.na(model_data$date_linear)] <- 0#
model_data$date_quadratic[is.na(model_data$date_quadratic)] <- 0#
#
ms.ss.occ <- nimbleCode({#
  ## Define prior distributions for community-level model parameters#
  cato_occ_mean ~ dunif(0,1)#
  mu_ucato <- log(cato_occ_mean) - log(1-cato_occ_mean)#
#
  fcw_occ_mean ~ dunif(0,1)#
  mu_ufcw <- log(fcw_occ_mean) - log(1-fcw_occ_mean)#
#
  cato_det_mean ~ dunif(0,1)#
  mu_vcato <- log(cato_det_mean) - log(1-cato_det_mean)#
#
  fcw_det_mean ~ dunif(0,1)#
  mu_vfcw <- log(fcw_det_mean) - log(1-fcw_det_mean)#
#
  ## random effects#
  sigma_ucato ~ dunif(0, 100)#
  sigma_ufcw ~ dunif(0, 100)#
  mu_a1 ~ dnorm(0, 0.001)#
  sigma_a1 ~ dunif(0, 100)#
  mu_a2 ~ dnorm(0, 0.001)#
  sigma_a2 ~ dunif(0, 100)#
  mu_a3 ~ dnorm(0, 0.001)#
  sigma_a3 ~ dunif(0, 100)#
  mu_a4 ~ dnorm(0, 0.001)#
  sigma_a4 ~ dunif(0, 100)#
#
  sigma_vcato ~ dunif(0, 100)#
  sigma_vfcw ~ dunif(0, 100)#
  mu_b1 ~ dnorm(0, 0.001)#
  sigma_b1 ~ dunif(0, 100)#
  mu_b2 ~ dnorm(0, 0.001)#
  sigma_b2 ~ dunif(0, 100)#
  for (i in 1:(num_species)) {#
    ## Create priors for species i from the community level prior#
    ## distributions#
#
    u_cato[i] ~ dnorm(mu_ucato, sd=sigma_ucato)#
    u_fcw[i] ~ dnorm(mu_ufcw, sd=sigma_ufcw)#
    a1[i] ~ dnorm(mu_a1, sd=sigma_a1)#
    a2[i] ~ dnorm(mu_a2, sd=sigma_a2)#
    a3[i] ~ dnorm(mu_a3, sd=sigma_a3)#
    a4[i] ~ dnorm(mu_a4, sd=sigma_a4)#
#
    v_cato[i] ~ dnorm(mu_vcato, sd=sigma_vcato)#
    v_fcw[i] ~ dnorm(mu_vfcw, sd=sigma_vfcw)#
    b1[i] ~ dnorm(mu_b1, sd=sigma_b1)#
    b2[i] ~ dnorm(mu_b2, sd=sigma_b2)#
#
    ## Major change: We can vectorize the calculation of psi.  This#
    ## means we don't need the for loop.  It reduces the number of#
    ## nodes in the model by a factor of num_points#
    logit(psi[1:num_points,i]) <-#
      u_cato[i]*(1-habitat_ind[1:num_points]) +#
        u_fcw[i]*habitat_ind[1:num_points] +#
          a1[i]*ufc_linear[1:num_points] +#
            a2[i]*ufc_quadratic[1:num_points] +#
              a3[i]*ba_linear[1:num_points] +#
                a4[i]*ba_quadratic[1:num_points]#
    ## We can also vectorize this#
    mu_psi[1:num_points,i] <- psi[1:num_points, i]#
#
    ## and this: For our purpose a better way to write this way is to#
    ## not worry that some elements of date_linear and date_quadratic#
    ## aren't used, since the benefit of vectorizing the computation#
    ## should be much greater than the cost of a few extra elements#
    logit(p[1:num_points, 1:max_num_reps, i]) <-#
      (v_cato[i]*(1-habitat_ind[1:num_points]) +#
       v_fcw[i]*habitat_ind[1:num_points]) %*%#
         asRow(onesRow[1, 1:max_num_reps])+#
           b1[i]*date_linear[1:num_points,1:max_num_reps] +#
             b2[i]*date_quadratic[1:num_points,1:max_num_reps]#
#
    ## This is the biggest change: We can write our own distribution#
    ## to combine the bernoulli occupancy and detection events.  We#
    ## can also make this is a single compuation for the entire matrix#
    ## of locations-x-visits, for each species (i) The code to define#
    ## dBernDetectionMatrix is below#
#
    X[1:num_points, 1:max_num_reps, i] ~ dBernDetectionMatrix(#
      occProb = mu_psi[1:num_points,i],#
      detectionProb = p[1:num_points, 1:max_num_reps,i],#
      num_reps = num_reps[1:num_points])#
  }#
  ## Derived quantities:#
  ## since we don't have Z's any more, I'm going to define these#
  ## derived quantities differently, as expected values.  One could#
  ## simply generate Z's at this predictive stage to capture that#
  ## additional variation or figure out derived quantities as wanted#
  ## for(j in 1:num_points){#
  ##   N_site[j]<- sum(mu_psi[j,1:(num_species)])#
  ##   N_ground[j]<- sum(mu_psi[j,1:num_species] * ground[1:num_species])#
  ##   N_mid[j]<- sum(mu_psi[j,1:num_species] * mid[1:num_species])#
  ## }#
})#
## zs are removed from these models#
model_data[["Z"]] <- NULL#
model_data[["ground"]] <- NULL#
model_data[["mid"]] <- NULL#
inits[["Z"]] <- NULL#
#
input1 <- list(code=ms.ss.occ,#
               constants=constants,#
               data=model_data,#
               inits=inits)#
## *********************************************************************#
## option 1 (vanilla NIMBLE) using compare MCMC#
## *********************************************************************#
#
ms.ss.opt1 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)#
#
save(ms.ss.opt1, file="saved/opt1.Rdata")
constants
rm(list=ls())#
setwd('~/Dropbox/occupancy-nimble/multiSpp-singleSea')#
#
## don't agument data#
n_zeroes <- 0#
source('src/initialize.R')#
#
## *********************************************************************#
## multi-species site-occupancy models: vectorized with custom#
## function to remove zs#
## *********************************************************************#
#
## Since calculations with date_linear and date_quadratic are now#
## vectorized, we'll set the NAs to 0#
model_data$date_linear[is.na(model_data$date_linear)] <- 0#
model_data$date_quadratic[is.na(model_data$date_quadratic)] <- 0#
#
ms.ss.occ <- nimbleCode({#
  ## Define prior distributions for community-level model parameters#
  cato_occ_mean ~ dunif(0,1)#
  mu_ucato <- log(cato_occ_mean) - log(1-cato_occ_mean)#
#
  fcw_occ_mean ~ dunif(0,1)#
  mu_ufcw <- log(fcw_occ_mean) - log(1-fcw_occ_mean)#
#
  cato_det_mean ~ dunif(0,1)#
  mu_vcato <- log(cato_det_mean) - log(1-cato_det_mean)#
#
  fcw_det_mean ~ dunif(0,1)#
  mu_vfcw <- log(fcw_det_mean) - log(1-fcw_det_mean)#
#
  ## random effects#
  sigma_ucato ~ dunif(0, 100)#
  sigma_ufcw ~ dunif(0, 100)#
  mu_a1 ~ dnorm(0, 0.001)#
  sigma_a1 ~ dunif(0, 100)#
  mu_a2 ~ dnorm(0, 0.001)#
  sigma_a2 ~ dunif(0, 100)#
  mu_a3 ~ dnorm(0, 0.001)#
  sigma_a3 ~ dunif(0, 100)#
  mu_a4 ~ dnorm(0, 0.001)#
  sigma_a4 ~ dunif(0, 100)#
#
  sigma_vcato ~ dunif(0, 100)#
  sigma_vfcw ~ dunif(0, 100)#
  mu_b1 ~ dnorm(0, 0.001)#
  sigma_b1 ~ dunif(0, 100)#
  mu_b2 ~ dnorm(0, 0.001)#
  sigma_b2 ~ dunif(0, 100)#
  for (i in 1:(num_species)) {#
    ## Create priors for species i from the community level prior#
    ## distributions#
#
    u_cato[i] ~ dnorm(mu_ucato, sd=sigma_ucato)#
    u_fcw[i] ~ dnorm(mu_ufcw, sd=sigma_ufcw)#
    a1[i] ~ dnorm(mu_a1, sd=sigma_a1)#
    a2[i] ~ dnorm(mu_a2, sd=sigma_a2)#
    a3[i] ~ dnorm(mu_a3, sd=sigma_a3)#
    a4[i] ~ dnorm(mu_a4, sd=sigma_a4)#
#
    v_cato[i] ~ dnorm(mu_vcato, sd=sigma_vcato)#
    v_fcw[i] ~ dnorm(mu_vfcw, sd=sigma_vfcw)#
    b1[i] ~ dnorm(mu_b1, sd=sigma_b1)#
    b2[i] ~ dnorm(mu_b2, sd=sigma_b2)#
#
    ## Major change: We can vectorize the calculation of psi.  This#
    ## means we don't need the for loop.  It reduces the number of#
    ## nodes in the model by a factor of num_points#
    logit(psi[1:num_points,i]) <-#
      u_cato[i]*(1-habitat_ind[1:num_points]) +#
        u_fcw[i]*habitat_ind[1:num_points] +#
          a1[i]*ufc_linear[1:num_points] +#
            a2[i]*ufc_quadratic[1:num_points] +#
              a3[i]*ba_linear[1:num_points] +#
                a4[i]*ba_quadratic[1:num_points]#
    ## We can also vectorize this#
    mu_psi[1:num_points,i] <- psi[1:num_points, i]#
#
    ## and this: For our purpose a better way to write this way is to#
    ## not worry that some elements of date_linear and date_quadratic#
    ## aren't used, since the benefit of vectorizing the computation#
    ## should be much greater than the cost of a few extra elements#
    logit(p[1:num_points, 1:max_num_reps, i]) <-#
      (v_cato[i]*(1-habitat_ind[1:num_points]) +#
       v_fcw[i]*habitat_ind[1:num_points]) %*%#
         asRow(onesRow[1, 1:max_num_reps])+#
           b1[i]*date_linear[1:num_points,1:max_num_reps] +#
             b2[i]*date_quadratic[1:num_points,1:max_num_reps]#
#
    ## This is the biggest change: We can write our own distribution#
    ## to combine the bernoulli occupancy and detection events.  We#
    ## can also make this is a single compuation for the entire matrix#
    ## of locations-x-visits, for each species (i) The code to define#
    ## dBernDetectionMatrix is below#
#
    X[1:num_points, 1:max_num_reps, i] ~ dBernDetectionMatrix(#
      occProb = mu_psi[1:num_points,i],#
      detectionProb = p[1:num_points, 1:max_num_reps,i],#
      num_reps = num_reps[1:num_points])#
  }#
  ## Derived quantities:#
  ## since we don't have Z's any more, I'm going to define these#
  ## derived quantities differently, as expected values.  One could#
  ## simply generate Z's at this predictive stage to capture that#
  ## additional variation or figure out derived quantities as wanted#
  ## for(j in 1:num_points){#
  ##   N_site[j]<- sum(mu_psi[j,1:(num_species)])#
  ##   N_ground[j]<- sum(mu_psi[j,1:num_species] * ground[1:num_species])#
  ##   N_mid[j]<- sum(mu_psi[j,1:num_species] * mid[1:num_species])#
  ## }#
})#
## zs are removed from these models#
model_data[["Z"]] <- NULL#
model_data[["ground"]] <- NULL#
model_data[["mid"]] <- NULL#
inits[["Z"]] <- NULL#
#
input1 <- list(code=ms.ss.occ,#
               constants=constants,#
               data=model_data,#
               inits=inits)#
## *********************************************************************#
## option 1 (vanilla NIMBLE) using compare MCMC#
## *********************************************************************#
#
ms.ss.opt1 <- compareMCMCs(input1,#
                           MCMCs=c('nimble', 'autoBlock'),#
                           niter=niter,#
                           burnin = burnin,#
                           summary=FALSE,#
                           check=FALSE)#
#
save(ms.ss.opt1, file="saved/opt1.Rdata")
names(model.data)
