modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = model)
C.modelMCMC$run(MCMCIter)
}
}
crossValidateOne(dyesModel, "y", 100, 2)
model$setData(modelDataList)
modelMCMCConf <- configureMCMC(model, monitors = dataNames)
modelMCMCConf$getMonitors()
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = model)
C.modelMCMC$run(MCMCIter)
head(as.matrix(C.modelMCMC$mvSamples))
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
browser()
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
compileNimble(model)
numBlocks <- model$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- model$getVarInfo(dataNames)[['maxs']]
for(i in 1:numBlocks){
modelDataNew <- array(values(model, dataNames), dim = c(dataDimensions))
evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
eval(parse(text = evalCode0))
evalCode1 <- paste0("modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= modelDataNew)")
eval(parse(text=evalCode2))
model$setData(modelDataList)
modelMCMCConf <- configureMCMC(model, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = model)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
}
crossValidateOne(dyesModel, "y", 100, 2)
Q
Q
Q
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
browser()
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
compileNimble(model)
numBlocks <- model$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- model$getVarInfo(dataNames)[['maxs']]
for(i in 1:numBlocks){
modelDataNew <- array(values(model, dataNames), dim = c(dataDimensions))
evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
eval(parse(text = evalCode0))
evalCode1 <- paste0("modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= modelDataNew)")
eval(parse(text=evalCode2))
model$setData(modelDataList)
modelMCMCConf <- configureMCMC(model, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = model)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
}
crossValidateOne(dyesModel, "y", 100, 2)
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
simDataArray
discrep <- sum((simDataArray - saveData)^2)
discrep
saveData
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
browser()
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
compileNimble(model)
numBlocks <- model$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- model$getVarInfo(dataNames)[['maxs']]
for(i in 1:numBlocks){
modelDataNew <- array(values(model, dataNames), dim = c(dataDimensions))
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
saveData <- modelDataNew
evalCode1 <- paste0("modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= modelDataNew)")
eval(parse(text=evalCode2))
model$setData(modelDataList)
modelMCMCConf <- configureMCMC(model, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = model)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
}
crossValidateOne(dyesModel, "y", 100, 2)
saveData
dyesModel$newModel()
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
for(i in 1:numBlocks){
modelDataNew <- array(values(newModel, dataNames), dim = c(dataDimensions))
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
saveData <- modelDataNew
evalCode1 <- paste0("modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= modelDataNew)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
}
crossValidateOne(dyesModel, "y", 100, 2)
saveData
?resetData
data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,
1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450, 1520, 1560,
1510, 1465, 1635, 1480, 1580, 1495, 1560, 1545, 1625, 1445), nrow = 6)
dyesModel$setData(list(y = data))
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
browser()
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
for(i in 1:numBlocks){
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("saveData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= saveData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
model$setData(saveData)
}
crossValidateOne(dyesModel, "y", 100, 2)
saveData
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
model$setData(saveData)
}
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
browser()
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
crossValidateOne <- function(model, dataNames, MCMCIter, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(1:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
}
model$setData(saveData)
}
crossValidateOne(dyesModel, "y", 100, 2)
saveData
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
simDataArray
discrep <- sum((simDataArray - saveData)^2)
discrep
simDataArray - saveData
discrep <- mean((simDataArray - saveData)^2)
discrep
discrep <- mean((simDataArray - saveData)^2
)
discrep
?numeric
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(burnIn:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
crossValValue <- lapply(burnIn:MCMCIter, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
crossValidateOne(dyesModel, "y", 100, 2)
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
sampNum <- dim(MCMCout)[1]
crossValValue <- lapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
output <- crossValidateOne(dyesModel, "y", 1000, 300, 2, 2)
crossValCalculate <- function(row, MCMCOut, dataDimensions, saveData){
simDataArray <- array(MCMCOut[row,], dim = c(dataDimensions))
discrep <- sum((simDataArray - saveData)^2)
return(discrep)
}
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
sampNum <- dim(MCMCout)[1]
crossValValue <- lapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
output <- crossValidateOne(dyesModel, "y", 1000, 300, 2, 2)
crossValValue
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
sampNum <- dim(MCMCout)[1]
browser()
crossValValue <- lapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
output <- crossValidateOne(dyesModel, "y", 1000, 300, 2, 2)
crossValValue <- lapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValValue
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
sampNum <- dim(MCMCout)[1]
browser()
crossValValue <- sapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
output <- crossValidateOne(dyesModel, "y", 1000, 300, 2, 2)
crossValValue <- sapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValValue
crossValidateOne <- function(model, dataNames, MCMCIter, burnIn, thin, leaveOutIndex){
## fill in each element of data along leaveOutIndex with NAs.
## then, data na values will be filled in as each mcmc runs.  These estimated data values can be compared to
## known data values, and the average loss (0/1) can be taken over all MCMC runs.  then take the average of these for all data points? woo!
newModel <- model$newModel()
compileNimble(newModel)
numBlocks <- newModel$getVarInfo(dataNames)[['maxs']][leaveOutIndex]
dataDimensions <- newModel$getVarInfo(dataNames)[['maxs']]
saveData <- array(values(newModel, dataNames), dim = c(dataDimensions))
crossValAverage <- numeric(numBlocks)
for(i in 1:numBlocks){
tempData <- saveData
# evalCode0 <- paste0("saveData <- modelDataNew[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"]")
# eval(parse(text = evalCode0))
newModel$resetData()
evalCode1 <- paste0("tempData[",rep(",", leaveOutIndex - 1), i, paste0(rep(",", length(dataDimensions) - leaveOutIndex)),"] <- NA")
eval(parse(text = evalCode1))
evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")
eval(parse(text=evalCode2))
newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel, monitors = dataNames, thin = thin)
modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC, project = newModel)
C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
sampNum <- dim(MCMCout)[1]
crossValValue <- sapply(ceiling(burnIn/thin):sampNum, crossValCalculate, MCMCout, dataDimensions, saveData)
crossValAverage[i] <- mean(crossValValue)
}
model$setData(saveData)
return(list(crossValAvgs = crossValAverage,
crossValAvgAvg = mean(crossValAverage)))
}
output <- crossValidateOne(dyesModel, "y", 1000, 300, 2, 2)
