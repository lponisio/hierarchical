rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
newModel <- prepModel$newModel()#
    tempData <- saveData#
    newModel$resetData()#
    compileNimble(newModel)
prepModel
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
newModel <- prepModel$newModel()#
    tempData <- saveData#
    newModel$resetData()#
    compileNimble(newModel)
evalCode1 <- paste0("tempData[",paste(rep(",", leaveOutIndex - 1),#
    collapse=""), i, paste(rep(",", length(dataDimensions) -#
                                   leaveOutIndex), collapse=""),"] <- NA")#
    eval(parse(text = evalCode1))#
    evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")#
    eval(parse(text=evalCode2))#
    newModel$setData(modelDataList)
modelMCMCConf <- configureMCMC(newModel,#
                                   monitors = dataNames, thin = thin)#
    modelMCMC <- buildMCMC(modelMCMCConf)
newModel$y
newModel$setData(modelDataList)
newModel$y
newModel <- prepModel$newModel()#
    tempData <- saveData#
    newModel$resetData()#
    compileNimble(newModel)#
    evalCode1 <- paste0("tempData[",paste(rep(",", leaveOutIndex - 1),#
    collapse=""), i, paste(rep(",", length(dataDimensions) -#
                                   leaveOutIndex), collapse=""),"] <- NA")#
    eval(parse(text = evalCode1))#
    evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")#
    eval(parse(text=evalCode2))#
    newModel$setData(modelDataList)#
    modelMCMCConf <- configureMCMC(newModel,#
                                   monitors = dataNames, thin = thin)#
    modelMCMC <- buildMCMC(modelMCMCConf)
newModel$y
newModel$getNodeNames(dataOnly=TRUE)
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
newModel <- prepModel$newModel()#
    compileNimble(newModel)#
    tempData <- saveData#
    newModel$resetData()#
    evalCode1 <- paste0("tempData[",paste(rep(",", leaveOutIndex - 1),#
    collapse=""), i, paste(rep(",", length(dataDimensions) -#
                                   leaveOutIndex), collapse=""),"] <- NA")#
    eval(parse(text = evalCode1))#
    evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")#
    eval(parse(text=evalCode2))#
    newModel$setData(modelDataList)#
    modelMCMCConf <- configureMCMC(newModel,#
                                   monitors = dataNames, thin = thin)#
    modelMCMC <- buildMCMC(modelMCMCConf)
newModel$y
newModel$getNodeNames(dataOnly=TRUE)
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
newModel <- prepModel$newModel()#
    compileNimble(newModel)#
    tempData <- saveData#
    newModel$resetData()#
    evalCode1 <- paste0("tempData[",paste(rep(",", leaveOutIndex - 1),#
    collapse=""), i, paste(rep(",", length(dataDimensions) -#
                                   leaveOutIndex), collapse=""),"] <- NA")
eval(parse(text = evalCode1))#
    evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")#
    eval(parse(text=evalCode2))#
    newModel$setData(modelDataList)#
    modelMCMCConf <- configureMCMC(newModel,#
                                   monitors = dataNames, thin = thin)#
    modelMCMC <- buildMCMC(modelMCMCConf)
newModel$getNodeNames(dataOnly=TRUE)
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
newModel <- prepModel$newModel()#
    compileNimble(newModel)#
    tempData <- saveData#
    newModel$resetData()#
    evalCode1 <- paste0("tempData[",paste(rep(",", leaveOutIndex - 1),#
    collapse=""), i, paste(rep(",", length(dataDimensions) -#
                                   leaveOutIndex), collapse=""),"] <- NA")#
    eval(parse(text = evalCode1))#
    evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")#
    eval(parse(text=evalCode2))
modelDataList
newModel$getNodeNames(dataOnly=TRUE)
newModel$setData(modelDataList)#
    modelMCMCConf <- configureMCMC(newModel,#
                                   monitors = dataNames, thin = thin)#
    modelMCMC <- buildMCMC(modelMCMCConf)
newModel$getNodeNames(dataOnly=TRUE)
newModel$getNodeNames(stochOnly=TRUE)
newModel$getNodeNames()
newModel$getNodeNames(data=FALSE)
?getNodeNames
newModel$getNodeNames(includeData=FALSE)
modelDataList
newModel$getNodeNames(dataOnly=TRUE)
C.modelMCMC$run(MCMCIter)
C.modelMCMC <- compileNimble(modelMCMC,#
                                 project = newModel,#
                                 resetFunctions = (i != 1))    #
    C.modelMCMC$run(MCMCIter)#
    MCMCout <- as.matrix(C.modelMCMC$mvSamples)
MCMCout
head(MCMCout)
Q
source('crossValidationFunction.R')
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
newModel <- prepModel$newModel()#
    compileNimble(newModel)#
    tempData <- saveData#
    newModel$resetData()#
    evalCode1 <- paste0("tempData[",paste(rep(",", leaveOutIndex - 1),#
    collapse=""), i, paste(rep(",", length(dataDimensions) -#
                                   leaveOutIndex), collapse=""),"] <- NA")#
    eval(parse(text = evalCode1))#
    ## create a list containing the data with the appropriate dataname#
    evalCode2 <- paste0("modelDataList <- list(", dataNames, "= tempData)")#
    eval(parse(text=evalCode2))#
    newModel$setData(modelDataList)
newModel$y
saveData
newModel$getNodeName(dataOnly=TRUE)
newModel$getNodeNames(dataOnly=TRUE)
newModel$getNodeNames(includeData=FASLE)
newModel$getNodeNames(includeData=FALSE)
modelMCMCConf <- configureMCMC(newModel,#
                                   monitors = dataNames, thin = thin)#
    modelMCMC <- buildMCMC(modelMCMCConf)
C.modelMCMC <- compileNimble(modelMCMC,#
                                 project = newModel,#
                                 resetFunctions = (i != 1))    #
    C.modelMCMC$run(MCMCIter)
MCMCout <- as.matrix(C.modelMCMC$mvSamples)
MCMCOUT
MCMCout
head(MCMCout)
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
output
output$crossVal
output$chain.diag
output$samples
head(output$samples)
head(output$samples[[1]])
head(output$samples[[2]])
head(output$samples[[3]])
head(output$samples[[4]])
head(output$samples[[5]])
output$chain.diag
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 100#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
lapply(samples, geweke.diag)
lapply(lapply(samples, geweke.diag),#
                                function(x) x$z)
chain.diag <-  do.call(cbind,#
                         lapply(lapply(samples, geweke.diag),#
                                function(x) x$z))
chain.diag
chain.diag <-  lapply(lapply(samples, geweke.diag),#
                                function(x) x$z)
chain.diag
chain.diag <- lapply(chain.diag, function(x) x[is.finite(x)])
chain.diag
chain.diag <-  lapply(lapply(samples, geweke.diag),#
                                function(x) x$z)#
  chain.diag <- do.call(cbind, lapply(chain.diag, function(x) x[is.finite(x)]))
chain.diag
Q
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 1000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
output$Chain.diag
output$chain.diag
output$crossVal
## ****************************************************#
dyesCodeSimp <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
          y[i,j] ~ dnorm(theta, sd = sigma)#
    }#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma ~ dunif(0, 100)#
})#
#
dyesModelSimp <- nimbleModel(dyesCodeSimp,#
                             constants =list(BATCHES = 6, SAMPLES = 5))#
dyesModelSimp$setData(list(y = data))#
#
output.simp <- crossValidateOne(dyesModelSimp, "y", 1000, 300, 2, 2)
output.simp$crossVal
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)#
## ****************************************************#
dyesCodeSimp <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
          y[i,j] ~ dnorm(theta, sd = sigma)#
    }#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma ~ dunif(0, 100)#
})#
#
dyesModelSimp <- nimbleModel(dyesCodeSimp,#
                             constants =list(BATCHES = 6, SAMPLES = 5))#
dyesModelSimp$setData(list(y = data))#
#
output.simp <- crossValidateOne(dyesModelSimp, "y", 1000, 300, 2, 2)
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)#
## ****************************************************#
dyesCodeSimp <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
          y[i,j] ~ dnorm(theta, sd = sigma)#
    }#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma ~ dunif(0, 100)#
})#
#
dyesModelSimp <- nimbleModel(dyesCodeSimp,#
                             constants =list(BATCHES = 6, SAMPLES = 5))#
dyesModelSimp$setData(list(y = data))#
#
output.simp <- crossValidateOne(dyesModelSimp,#
                                "y", niter, niter*0.1, 2, 2)
output$crossVal
simp.output
output.simp
output.simp$crossVal
output$crossVal
output$chain.diag
output.simp$chain.diag
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
model$getNodeInfo
model$getNodeInfo()
?getNodeNAmes
?getNodeNames
model$expandNodeNames
model$expandNodeNames()
model$expandNodeNames(dataNames)
model$expandNodeNames("hello")
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
model$expandNodeNames(dataNames)
all(model$expandNodeNames(dataNames) %in% model$getNodesNames(dataOnly=TRUE))
all(model$expandNodeNames(dataNames) %in%#
     model$getNodeNames(dataOnly=TRUE))
all(model$expandNodeNames("tomato") %in%#
     model$getNodeNames(dataOnly=TRUE))
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
testDataNames <- try(all(model$expandNodeNames(dataNames) %in%#
                           model$getNodeNames(dataOnly=TRUE)), silent=TRUE)
testDataNames
if(inherits(testDataNames, "try-error") | testDataNames == FALSE){#
    stop(paste0("dataNames", dataNames, "is not the name of data in model"))#
  }
testDataNames <- try(all(model$expandNodeNames("tomato") %in%#
                           model$getNodeNames(dataOnly=TRUE)), silent=TRUE)#
  if(inherits(testDataNames, "try-error") | testDataNames == FALSE){#
    stop(paste0("dataNames", dataNames, "is not the name of data in model"))#
  }
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "x",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "x",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
rm(list=ls())#
library(nimble)#
library(parallel)#
setwd('~/Dropbox/nimble/occupancy/analysis/crossValidation')#
source('crossValidationFunction.R')#
#
dyesCode <- nimbleCode({#
  for (i in 1:BATCHES) {#
    for (j in 1:SAMPLES) {#
      y[i,j] ~ dnorm(mu[i], sd = sigma.within);#
    }#
    mu[i] ~ dnorm(theta, sd = sigma.between);#
  }#
  theta ~ dnorm(0.0, 1.0E-10);#
  sigma.within ~ dunif(0, 100)#
  sigma.between ~ dunif(0, 100)#
})#
#
dyesModel <- nimbleModel(dyesCode,#
                         constants = list(BATCHES = 6, SAMPLES = 5))#
#
## data <- matrix(c(1545, 1540, 1595, 1445, 1595, 1520, 1440, 1555, 1550,#
##                  1440, 1630, 1455, 1440, 1490, 1605, 1595, 1515, 1450,#
##                  1520, 1560, 1510, 1465, 1635, 1480, 1580, 1495, 1560,#
##                  1545, 1625, 1445), nrow = 6)#
#
data <- cbind(rnorm(6, 0, 1), rnorm(6, 6, 1), rnorm(6, 4, 1),#
              rnorm(6, 7, 1),#
              rnorm(6, 5, 1))#
#
dyesModel$setData(list(y = data))#
#
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "x",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
options(mc.cores=1)#
niter <- 10000#
output <- crossValidateOne(model=dyesModel,#
                           dataNames= "y",#
                           MCMCIter= niter,#
                           burnIn=niter*0.1,#
                           thin=1,#
                           leaveOutIndex=2,#
                           MCMCdefs=NULL)
