rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")
## library(devtools)#
## install_github("nimble-dev/nimble",#
##                ref = "devel",#
##                subdir = "packages/nimble")#
#
library(nimble)#
library(mcmcplots)#
library(igraph)#
library(raster)#
library(gstat)#
library(lattice)#
library(mvtnorm)#
library(ncf)#
#
source("src/runNimble.R")#
source("src/plotting.R")#
#
expit <- function(x) 1/(1+exp(-x))#
logit <- function(x) log(x/(1-x))#
#
## parameters#
N <- 100#
alpha <- 0.1#
beta1 <- 2#
nreps <- 10#
p <- 0.5#
sigma <- 0.5#
#
set.seed(44)#
#
rmvn <- function(n, mu = 0, V = matrix(1)) {#
  p <- length(mu)#
  if (any(is.na(match(dim(V), p)))) #
    stop("Dimension problem!")#
  D <- chol(V)#
  t(matrix(rnorm(n * p), ncol = p) %*% D + rep(mu, rep(n, p)))#
}#
#
## Set up a square lattice region#
simgrid <- expand.grid(1:50, 1:50)#
n <- nrow(simgrid)#
#
## Set up distance matrix#
distance <- as.matrix(dist(simgrid))#
## Generate random variable#
delta <- 0.05#
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))#
#
elev <- raster(matrix(rnorm(n), 50, 50),#
               xmn = 0, xmx = 50,#
               ymn = 0, ymx = 50)#
#
psi <- expit(alpha + beta1 * values(elev) +  values(Xraster))#
#
z <- rbinom(n = n, size = 1, prob = psi)  ## Latent occurrence state#
#
z <- rasterFromXYZ(cbind(coordinates(elev), z))
id <- sample(1:n, N)#
coords <- coordinates(counts)[id, ]
coords <- coordinates(z)[id, ]
coords
dat <- data.frame(coords, elev = extract(elev, coords),#
                  Xvar = extract(Xraster, coords),#
                  counts = extract(z, coords))
dat
head(data)
head(dats)
head(dat)
## library(devtools)#
## install_github("nimble-dev/nimble",#
##                ref = "devel",#
##                subdir = "packages/nimble")#
#
library(nimble)#
library(mcmcplots)#
library(igraph)#
library(raster)#
library(gstat)#
library(lattice)#
library(mvtnorm)#
library(ncf)#
#
source("src/runNimble.R")#
source("src/plotting.R")#
#
expit <- function(x) 1/(1+exp(-x))#
logit <- function(x) log(x/(1-x))#
#
## parameters#
N <- 100#
nreps <- 10#
alpha <- 0.1#
beta1 <- 2#
p <- 0.5#
sigma <- 0.5#
#
set.seed(44)#
#
rmvn <- function(n, mu = 0, V = matrix(1)) {#
  p <- length(mu)#
  if (any(is.na(match(dim(V), p)))) #
    stop("Dimension problem!")#
  D <- chol(V)#
  t(matrix(rnorm(n * p), ncol = p) %*% D + rep(mu, rep(n, p)))#
}#
#
## Set up a square lattice region#
simgrid <- expand.grid(1:50, 1:50)#
n <- nrow(simgrid)#
#
## Set up distance matrix#
distance <- as.matrix(dist(simgrid))#
## Generate random variable#
delta <- 0.05#
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))#
#
elev <- raster(matrix(rnorm(n), 50, 50),#
               xmn = 0, xmx = 50,#
               ymn = 0, ymx = 50)#
#
psi <- expit(alpha + beta1 * values(elev) +  values(Xraster))#
#
z <- rbinom(n = n, size = 1, prob = psi)  ## Latent occurrence state#
#
z <- rasterFromXYZ(cbind(coordinates(elev), z))#
#
coords <- coordinates(z)#
fulldata <- data.frame(coords,#
                       elevation = extract(elev, coords),#
                       Xvar = extract(Xraster, coords),#
                       z = extract(z, coords))#
#
sites <- sample(1:n, N)#
sampledata <- fulldata[sites, ]
## Observation process: Sample detection/nondetection observations#
## from a Bernoulli(with p) if z=1#
y <- matrix(NA, nrow = N, ncol = nreps)#
#
for (j in 1:nreps){#
  y[,j] <- rbinom(n = N, size = 1, prob = sampledata$z * p)#
}
y
distance
sampledata
dim(distances)
head(distances)
head(distance)
dim(distance)
sites
distance[sites, sites]
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")
## library(devtools)#
## install_github("nimble-dev/nimble",#
##                ref = "devel",#
##                subdir = "packages/nimble")#
#
library(nimble)#
library(mcmcplots)#
library(igraph)#
library(raster)#
library(gstat)#
library(lattice)#
library(mvtnorm)#
library(ncf)#
#
source("src/runNimble.R")#
source("src/plotting.R")#
#
expit <- function(x) 1/(1+exp(-x))#
logit <- function(x) log(x/(1-x))
## parameters#
N <- 100#
nreps <- 10#
alpha <- 0.1#
beta1 <- 2#
p <- 0.5#
sigma <- 0.5#
#
set.seed(44)#
#
rmvn <- function(n, mu = 0, V = matrix(1)) {#
  p <- length(mu)#
  if (any(is.na(match(dim(V), p)))) #
    stop("Dimension problem!")#
  D <- chol(V)#
  t(matrix(rnorm(n * p), ncol = p) %*% D + rep(mu, rep(n, p)))#
}
## Set up a square lattice region#
simgrid <- expand.grid(1:50, 1:50)#
n <- nrow(simgrid)#
#
## Set up distance matrix#
distance <- as.matrix(dist(simgrid))#
## Generate random variable#
delta <- 0.05#
X <- rmvn(1, rep(0, n),  (sigma^2)*exp(-delta * distance))#
Xraster <- rasterFromXYZ(cbind(simgrid[, 1:2] - 0.5, X))#
#
elev <- raster(matrix(rnorm(n), 50, 50),#
               xmn = 0, xmx = 50,#
               ymn = 0, ymx = 50)#
#
psi <- expit(alpha + beta1 * values(elev) +  values(Xraster))#
#
z <- rbinom(n = n, size = 1, prob = psi)  ## Latent occurrence state#
#
z <- rasterFromXYZ(cbind(coordinates(elev), z))
coords <- coordinates(z)#
fulldata <- data.frame(coords,#
                       elevation = extract(elev, coords),#
                       Xvar = extract(Xraster, coords),#
                       z = extract(z, coords))#
#
sites <- sample(1:n, N)#
sampledata <- fulldata[sites, ]
y <- matrix(NA, nrow = N, ncol = nreps)#
#
for (j in 1:nreps){#
  y[,j] <- rbinom(n = N, size = 1, prob = sampledata$z * p)#
}
model.data <- list(D = distance[sites, sites],#
                   y = y,#
                   zeros=rep(0, n),#
                   elev = sampledata$elevation)
model.data
## model data#
## y <- as.vector(as.matrix(y))#
model.data <- list(D = distance[sites, sites],#
                   y = y,#
                   zeros=rep(0, N),#
                   elev = sampledata$elevation)
model.data$D
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
N
nreps
dim(z)
sampledata
## Observation process: Sample detection/nondetection observations#
## from a Bernoulli(with p) if z=1#
y <- matrix(NA, nrow = n, ncol = nreps)#
#
for (j in 1:nreps){#
  y[,j] <- rbinom(n = n, size = 1, prob = z * p)#
}#
#
ysample <- y#
ysample[-sites, ] <- NA
n
z
for (j in 1:nreps){#
  y[,j] <- rbinom(n = n, size = 1, prob = fulldata$z * p)#
}#
#
ysample <- y#
ysample[-sites, ] <- NA
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
ysample
dim(ysample)
length(ylample)
ysample <- y#
ysample[-sites, ] <- NA
length(ylample)
dim(ysample)
ysample <- as.vector(as.matrix(ysample))
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
fulldata$elevation
ysample
length(ysample)
length(distance)
head(fulldata)
simgrid
distance
dim(distance)
n
length(ysample)
nreps
N
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
model.data <- list(D = distance[sites, sites],#
                   y = ysample[!is.na(ysample)],#
                   zeros=rep(0, N),#
                   elev = fulldata$elevation[sites, ])
model.data <- list(D = distance[sites, sites],#
                   y = ysample[!is.na(ysample)],#
                   zeros=rep(0, N),#
                   elev = fulldata$elevation[sites])
head(model.data)
lapply(model.data, length)
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)
sites
N*N
sites
fulldata$elevation
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)#
#
save(sp.mod.opt1, file="saved/opt1.Rdata")#
#
checkChains(sp.mod.opt1[[1]]$samples,#
            f.path = "figures/chains/%s.pdf")
rm(list=ls())#
setwd("~/Dropbox/nimble-dev/occupancy/spatial")#
source('src/initialize.R')#
sp.mod <- nimbleCode({#
  ## priors#
  delta ~ dunif(0,10)#
  sigma ~ dunif(0,10)#
  psi ~ dunif(0, 1)#
  p ~ dunif(0, 1)#
  alpha ~ dnorm(0, 0.001)#
  b1 ~ dnorm(0, 0.001)#
#
  ## Likelihood#
  ## Ecological model for true occurrence#
  for (i in 1:N) {#
    z[i] ~ dbern(psi[i])#
    logit(psi[i]) <- alpha + b1*elev[i] + rho[i]#
    p.eff[i] <- z[i] * p#
#
    ## Observation model for replicated detection/nondetection observations#
    for (j in 1:nreps) {#
      y[i,j] ~ dbern(p.eff[i])#
    }#
  }#
#
  rho[1:N] ~ dmnorm(zeros[1:N], cov = D.cov) #
  ## derived quantities#
  for(i in 1:N){#
    for(j in 1:N){#
      ## turning the distance matrix to covariance matrix#
      D.covar[i,j] <- (sigma^2)*exp(-delta*D[i,j])#
    }#
  }#
#
})#
#
input1 <- list(code=sp.mod,#
                       constants=constants,#
                       data=model.data,#
                       inits=inits)#
sp.mod.opt1 <- compareMCMCs(input1,#
                                MCMCs=c('nimble'),#
                                niter=niter,#
                                burnin = burnin,#
                                summary=FALSE,#
                           check=FALSE)#
#
save(sp.mod.opt1, file="saved/opt1.Rdata")#
#
checkChains(sp.mod.opt1[[1]]$samples,#
            f.path = "figures/chains/%s.pdf")
